{"name":"ELIoT","tagline":"Extensible Language for the Internet of Things","body":"# ELIoT\r\n### Extensible Language for the Internet of Things\r\n\r\nELIoT is a very simple and small programming language specifcally\r\ndesigned to facilitate the configuration and control of swarms of\r\nsmall devices such as sensors or actuators. It can also be used as a\r\npowerful, remotely-accessible extension language for larger\r\napplications.\r\n\r\n\r\n## Example: Measuring temperature\r\n\r\nConsider a sensor named `sensor.corp.net` running ELIoT and featuring\r\na temperature measurement through a `temperature` function.\r\n\r\nELIoT lets you evaluate programss on this sensor remotely to do all\r\nkind of interesting temperature measurements. By deferring\r\ncomputations to the sensor, we minimize network traffic and energy\r\nconsumption. Examples similar to the ones below can be found in the\r\n[demo directory](https://github.com/c3d/eliot/tree/master/demo).\r\n\r\n### Simple temperature measurement (polling)\r\n\r\nTo measure the temperature on a remote node called \"sensor.corp.net\",\r\nuse the following code:\r\n\r\n    temperature_on_sensor -> ask \"sensor.corp.net\", { temperature }\r\n    writeln \"Temperature is \", temperature_on_sensor\r\n\r\nThe `->` rewrite operator reads \"transforms into\" and is used in ELIoT\r\nto define variables, functions, macros, and so on. Look into\r\n[builtins.eliot](https://github.com/c3d/eliot/blob/master/src/builtins.eliot)\r\nfor examples of its use.\r\n\r\nThe `ask` function sends a program on a remote node, waits for its\r\ncompletion, and returns the result. So each time we call\r\n`temperature_on_sensor`, we send a program containing `temperature` on\r\nthe remote node called `sensor.corp.net`, and wait for the measured\r\nvalue.\r\n\r\n\r\n### Reporting sudden changes in temperatures\r\n\r\nAn application may be interested in sudden changes in temperatures,\r\ne.g. if the sensor suddenly warms up. With ELIoT, without changing\r\nanything to the temperature API, you can check the temperature every\r\nsecond and report if it changed by more than 1 degree since last time\r\nit was measured with the following program:\r\n\r\n    invoke \"sensor.corp.net\",\r\n        last_temperature := temperature\r\n        every 1s,\r\n            check_temperature temperature\r\n        check_temperature T:real ->\r\n            writeln \"Measuring temperature \", T, \" from process \", process_id\r\n            if abs(T - last_temperature) >= 1.0 then\r\n                reply\r\n                    temperature_changed T, last_temperature\r\n            last_temperature := T\r\n    temperature_changed new_temp, last_temp ->\r\n        writeln \"Temperature changed from \", last_temp, \" to \", new_temp\r\n\r\nThe `invoke` function sends a program to the remote node and opens a\r\nbi-directional connexion, which allows the sensor to `reply` when it\r\nfeels it has useful data to report. In that case, the sensor replies\r\nwith a call to `temperature_changed`, sending back the old and new\r\ntemperature, and the controlling node can display a message using\r\n`writeln`.\r\n\r\n\r\n\r\n### Reporting changes in temperatures since last report\r\n\r\nAnother application may be interested in how temperature changes over\r\ntime, even if it's gradual. In that case, you want to report\r\ntemperature if it changes by more than one degree since last time it\r\nwas *reported* (instead of measured). You can do that with a slight\r\nvariation in the code above, so that you update `last_temperature`\r\nonly after having transmitted the new value, not after having measured it:\r\n\r\n    invoke \"sensor.corp.net\",\r\n        last_temperature := temperature\r\n        every 1s,\r\n            check_temperature temperature\r\n        check_temperature T:real ->\r\n            writeln \"Measuring temperature \", T, \" from process \", process_id\r\n            if abs(T - last_temperature) >= 1.0 then\r\n                reply\r\n                    temperature_changed T, last_temperature\r\n                last_temperature := T\r\n    temperature_changed new_temp, last_temp ->\r\n        writeln \"Temperature changed from \", last_temp, \" to \", new_temp\r\n\r\nIn ELIoT, indentation is significant, and defined \"blocks\" of\r\ncode. Other ways to delimit a block of code include brackets\r\n`{ code }` (which we used in the first example for `{ temperature }`,\r\nas well as parentheses `( code )` or square brackets `[ code ]`. The\r\nlatter two are used for expressions.\r\n\r\n\r\n### Computing average, min and max temperatures\r\n\r\nAgain using the same sensor, and again without any code or API change\r\non the sensor, you can also have it compute min, max and average\r\ntemperatures from samples taken every 2.5 seconds:\r\n             \r\n    invoke \"sensor.corp.net\",\r\n        min   -> 100.0\r\n        max   -> 0.0\r\n        sum   -> 0.0\r\n        count -> 0\r\n\r\n        compute_stats T:real ->\r\n            min   := min(T, min)\r\n            max   := max(T, max)\r\n            sum   := sum + T\r\n            count := count + 1\r\n            reply\r\n                report_stats count, T, min, max, sum/count\r\n\r\n        every 2.5s,\r\n            compute_stats temperature\r\n\r\n    report_stats Count, T, Min, Max, Avg ->\r\n        writeln \"Sample \", Count, \" T=\", T,\r\n                \" Min=\", Min, \" Max=\", Max, \" Avg=\", Avg\r\n\r\nNotice how the first parameter of `compute_stats`, `T`, has a type\r\ndeclaration `T:real`. This tells ELIoT that a `real` value is expected\r\nhere. But it also forces ELIoT to actually compute the value, in order\r\nto check that it is indeed a real number.\r\n\r\nAs a result, `temperature` is evaluated only once (to bind it to\r\n`T`). If we had done the computation by replacing `T` with\r\n`temperature`, we might have gotten inconsistent readings between two\r\nsubsequent evaluations of `temperature`, yielding possibly incorrect\r\nresults.\r\n\r\n\r\n### Computing the difference between two sensors\r\n\r\nImagine now that you have two temperature sensors called\r\n`sensor1.corp.net` and `sensor2.corp.net`, located in Sydney,\r\nAustralia, while your controlling application is located in Sydney,\r\nCanada. If you need the difference in temperature between the two\r\nsensors, wouldn't it make sense to minimize the traffic between Canada\r\nand Australia, and have the two sensors talk to one another locally in\r\nAustralia?\r\n\r\nThis is very easy with ELIoT. The following program will only send a\r\ntraffic across the ocean if the temperature between the two sensors\r\ndiffers by more than 2 degrees, otherwise all network traffic will\r\nremain local:\r\n\r\n    invoke \"sensor2.corp.net\",\r\n       every 1.1s,\r\n            sensor1_temp ->\r\n                ask \"sensor1.corp.net\",\r\n                    temperature\r\n            send_temps sensor1_temp, temperature\r\n\r\n       send_temps T1:real, T2:real ->\r\n           if abs(T1-T2) > 2.0 then\r\n               reply\r\n                   show_temps T1, T2\r\n\r\n    show_temps T1:real, T2:real ->\r\n        write \"Temperature on sensor1 is \", T1, \" and on sensor2 \", T2, \". \"\r\n        if T1>T2 then\r\n            writeln \"Sensor1 is hotter by \", T1-T2, \" degrees\"\r\n        else\r\n            writeln \"Sensor2 is hotter by \", T2-T1, \" degrees\"\r\n\r\nThis program looks and behaves like a single program, but will\r\nactually be executing on three different machines that may possibly\r\nlocated hundreds of miles from one another.\r\n\r\n\r\n### A very powerful, yet simple API\r\n\r\nWith these examples, we have demonstrated that using ELIoT, we can\r\nanswer queries from applications that have very different requirements.\r\nAn application will get exactly the data it needs, when it needs it,\r\nminimizing network traffic and optimizing energy utiliation.\r\n\r\nYet the API on the sensors and on the controlling computer is\r\nextremely simple. On the sensor, we only have a single function\r\nreturning the temperature. And on the controlling computer, we have a\r\nsingle language that deals with data collection, timing, exchange\r\nbetween nodes, computations, and more.\r\n\r\n\r\n## How do we measure the temperature?\r\n\r\nIt is very simple to add your own functions to ELIoT, and to call any\r\nC or C++ function of your choosing. The `temperature` function is\r\nimplemented in a file called\r\n[temperature.tbl](https://github.com/c3d/eliot/blob/master/src/temperature.tbl).\r\nIt looks like this:\r\n\r\n    NAME_FN(Temperature,            // Unique internal name\r\n            real,                   // Return value\r\n            \"temperature\",          // Name for ELIOT programmers\r\n\r\n            // C++ code to compute the temperature and return it\r\n            std::ifstream is(\"/sys/class/thermal/thermal_zone0/temp\");\r\n            int tval;\r\n            is >> tval;\r\n            R_REAL(tval * 0.001));\r\n\r\nIn that code, we read core temperature data as reported by Linux on\r\nRaspberry Pi by reading the system file `/sys/class/thermal/thermal_zone0/temp`.\r\nThis file returns values in 1/1000th of a Celsius, so we multiply the\r\nvalue we read by 0.001 to get the actual temperature.\r\n\r\nTo add the `temperature` module to ELIoT, we just need to add it to\r\nthe list of modules in the\r\n[Makefile](https://github.com/c3d/eliot/blob/master/src/Makefile#L32):\r\n\r\n    # List of modules to build\r\n    MODULES=basics io math text remote time-functions temperature\r\n\r\nThis will build at least `temperature.tbl`. That file contains the\r\ninterface between ELIoT and your code. In simple cases like our\r\ntemperature measurement, it may be sufficient. However, if you have\r\nfiles called `temperature.h` or `temperature.cpp`, they will be\r\nintegrated in your `temperature` module. This lets you add supporting\r\nclasses or functions.\r\n\r\nThe `tell`, `ask`, `invoke` and `reply` words are implemented in the\r\nmodule called `remote`, which consists of\r\n[remote.tbl](https://github.com/c3d/eliot/blob/master/src/remote.tbl),\r\n[remote.h](https://github.com/c3d/eliot/blob/master/src/remote.h) and\r\n[remote.cpp](https://github.com/c3d/eliot/blob/master/src/remote.cpp).\r\nThis may not be the easiest module to study, however. You may find\r\n[io.tbl](https://github.com/c3d/eliot/blob/master/src/io.tbl) easier\r\nto understand.\r\n\r\n\r\n## Compiling ELIoT\r\n\r\nTo build ELIoT, just use `make`. On a Raspberry Pi, a `make -j3`\r\nshould run in about 10 minutes if you start from scratch. On a version\r\n2, it's about one minute. On a modern PC, it's may be as low as 3 to 5\r\nseconds. If `make` works (and it should), then use `sudo make install`\r\nto install the target. In summary:\r\n\r\n      % make\r\n      % sudo make install\r\n\r\nThe default location is `/usr/local/bin/eliot`, but you can install in\r\n`/opt/local/` for example by building with `make PREFIX=/opt/local/`.\r\nDon't forget the trailing `/`.\r\n\r\nIf you are paranoid, you can, from the top-level, run `make check` to\r\nvalidate that your installation is running correctly. It is possible\r\nfor a test named `04-basic-operators-in-function` to fail on some\r\nmachines, because C arithmetic for `<<` and `>>` operators is not\r\nportable. I will fix that one day. If other tests fail, look into\r\nfile `tests/failures-default.out` for details of what went wrong.\r\n\r\n\r\n### Running an ELIoT server\r\n\r\nTo start an ELIoT server on a node, simply run `eliot -l`.\r\n\r\n    pi% eliot -l\r\n\r\nBy default, ELIoT listens on port 1205. You can change that by using\r\nthe `-listen` option:\r\n\r\n    pi% eliot -listen 42105\r\n\r\nNow, let's try a first test program. On `boss`, edit a file called\r\n`hello.eliot`, and write into it the following code:\r\n\r\n    tell \"pi\",\r\n        writeln \"Hello World\"\r\n\r\nReplace `\"pi\"` with the actual Internet name of your target\r\nmachine. Then execute that little program with:\r\n\r\n    boss% eliot hello.eliot\r\n\r\nNormally, the console output on `pi` should now look like this:\r\n\r\n    pi% eliot -l\r\n    Hello World\r\n\r\nWhat happens behind the scene is that ELIoT on `boss` sent the program\r\ngiven as an argument to `tell` to the machine named `pi` (which must\r\nbe running an ELIoT in listen mode, i.e. have `eliot -l`\r\nrunning). Then, that program executes on the slave. The `tell` command\r\nis totally asynchronous, it does not wait for completion on the target.\r\n\r\nIf this example does not work as intended, and if no obvious error\r\nappears on the console of either system, you can debug things by\r\nadding `-tremote` (`-t` stands for \"trace\", and enables specific debug\r\ntraces, in that case any code conditioned by `IFTRACE(remote)` in the\r\nELioT source code).\r\n\r\n\r\n### The magic behind the scene\r\n\r\nThere are three key functions to send programs across nodes:\r\n\r\n * `tell` sends a program asynchronously\r\n * `ask` sends a program synchronously and waits for the result\r\n * `invoke` sends a program and opens a bi-directional channel.\r\n   The node can then use `reply` to execute code back in the caller's\r\n   program\r\n\r\nELIoT sends not just the program segments you give it, but also the\r\nnecessary data, notably the symbols required for correct evaluation. \r\nThis is the reason why things appear to work as a single program.\r\n\r\n\r\n\r\n## Basics of ELIoT syntax and semantics\r\n\r\nELIoT derives from [XLR](http://xlr.sourceforge.net). It is a\r\nspecially trimmed-down version that does not require LLVM and can work\r\nin full interpreted mode, making it easier to compiler and use, but\r\nalso safer, since you cannot call arbitrary C functions.\r\n\r\n### Semantics: One operator to rule them all\r\n\r\nELIoT has one fundamental operator, `->`, the \"rewrite operator\",\r\nwhich reads as *transforms into*. It is used to declare variables:\r\n\r\n    X -> 0\r\n\r\nIt can be used to declare functions:\r\n\r\n    add_one X -> X + 1\r\n\r\nThe rewrite operator  can be used to declare other operators:\r\n\r\n    X + Y -> writeln \"Adding \", X, \" and \", Y; X - (-Y)\r\n\r\nBut it is a more general tool than the operator overloading found in\r\nmost other languages, in particular since it allows you to easily\r\noverload combinations of operators, or special cases:\r\n\r\n    A in B..C -> A >= B and A <= C\r\n    X * 1 -> X\r\n\r\nRewrites are considered in program order, and pattern matching finds\r\nthe first one that applies. For example, factorial is defined as follows:\r\n\r\n    0! -> 1\r\n    N! -> N * (N-1)!\r\n\r\nMany basic program structures are defined that way in\r\n[builtins.eliot](https://github.com/c3d/eliot/blob/master/src/builtins.eliot).\r\nFor example, if-then-else and infinite loops are defined as follows:\r\n\r\n    if true  then X else Y      -> X\r\n    if false then X else Y      -> Y\r\n    loop Body                   -> Body; loop Body\r\n\r\n\r\n### Syntax: Look, Ma, no keywords!\r\n\r\nELIoT has no keywords. Instead, the syntax relies on a rather simple\r\n[recursive descent](https://en.wikipedia.org/wiki/Recursive_descent_parser)\r\n[parser](https://github.com/c3d/eliot/blob/master/src/parser.cpp).\r\n\r\nThe parser has no keywords, and generates a parse tree made of * node\r\ntypes. The first four node types are leaf nodes:\r\n\r\n * `Integer` is for integer numbers such as `2` or `16#FFFF_FFFF`.\r\n * `Real` is for real numbers such as `2.5` or `2#1.001_001_001#e-3`\r\n * `Text` is for text values such as `\"Hello\" or `'World'`. Text can\r\n   be encoded using UTF-8\r\n * `Name` is for names and symbols such as `ABC` or `**`\r\n\r\nThe last four node types are inner nodes:\r\n\r\n * `Infix` are nodes where a named operator separates the operands,\r\n   e.g. `A+B` or `A and B`.\r\n * `Prefix` are nodes where the operator precedes the operand, e.g.\r\n   `+X` or `sin X`. By default, functions are prefix.\r\n * `Postfix` are nodes where the operator follows the operand, e.g.\r\n   `3%` or `5km`.\r\n * `Block` are nodes with only one child surrounded by delimiters,\r\n   such as `(A)`, `[A]` or `{A}`.\r\n\r\nOf note, the line separator is an infix that separates statements,\r\nmuch like the semi-colon `;`. The comma `,` infix is traditionally\r\nused to build lists or to separate the argument of\r\nfunctions. Indentation forms a special kind of block.\r\n\r\nFor example, the following code:\r\n\r\n    tell \"foo\",\r\n        if A < B+C then\r\n            hello\r\n        world\r\n\r\nparses as a prefix `tell`, with an infix `,` as its right argument. On\r\nthe left of the `,` there is the text `\"foo\"`. On the right, there is\r\nan indentation block with a child that is an infix line separator. On\r\nthe left of the line separator is the `if` statement. On the right is\r\nthe name `world`.\r\n\r\nThis parser is dynamically configurable, with the default priorities\r\nbeing defined by the\r\n[eliot.syntax](https://github.com/c3d/eliot/blob/master/src/eliot.syntax) file.\r\n\r\nParse trees are the fundamendal data structure in ELIoT. Any data or\r\nprogram can be represented as a parse tree.\r\n\r\n\r\n### ELIoT as a functional language\r\n\r\nELIoT can be seen as a functional language, where functions are\r\nfirst-class entities, i.e. you can manipulate them, pass them around,\r\netc:\r\n\r\n    adder X:integer -> (Y -> Y + X)\r\n\r\n    add3 := adder 3\r\n    add5 := adder 5\r\n\r\n    writeln \"3+2=\", add3 2\r\n    writeln \"5+17=\", add5 17\r\n    writeln \"8+2=\", (adder 8) 2\r\n\r\nHowever, it is a bit different in the sense that the core data\r\nstructure is the parse tree. Some specific parse trees, for example\r\n`A+B`, are not naturally reduced to a function call, although they are\r\nsubject to the same evaluation rules based on tree rewrites.\r\n\r\n\r\n### Subtlety #1: expression vs. statement\r\n\r\nThe ELIoT parse tree is designed to represent programs in a way that\r\nis relatively natural for human beings. In that sense, it departs from\r\nlanguages such as Lisp or SmallTalk.\r\n\r\nHowever, being readable for humans requires a few special rules to\r\nmatch the way we read expressions. Consider for example the following:\r\n\r\n    write sin X, cos Y\r\n\r\nMost human being parse this as meaning `write (sin(X),cos(Y))`,\r\ni.e. we call `write` with two values resulting from evaluating `sin X`\r\nand `cos Y`. This is not entirely logical. If `write` takes\r\ncomma-separated arguments, why wouldn't `sin` also take\r\ncomma-separated arguments? In other words, why doesn't this parse as\r\n`write(sin(X, cos(Y))`?\r\n\r\nThis shows that humans have a notion of *expressions*\r\nvs. *statements*. Expressions such as `sin X` have higher priority\r\nthan commas and require parentheses if you want multiple arguments. By\r\ncontrast, statements such as `write` have lower priority, and will\r\ntake comma-separated argument lists. An indent or `{ }` block begins a\r\nstatement, whereas parentheses `()` or square brackets `[]` begin an\r\nexpression.\r\n\r\nThere are rare cases where the default rule will not achieve the\r\ndesired objective, and you will need additional parentheses.\r\n\r\n### Subtlety #2: infix vs. prefix\r\n\r\nAnother special rule is that ELIoT will use the presence of space on\r\nonly one side of an operator to disambiguate between an infix or a\r\nprefix. For example:\r\n\r\n    write -A    // write (-A)\r\n    B - A       // (B - A)\r\n\r\n### Subtlety #3: Delayed evaluation\r\n\r\nWhen you pass an argument to a function, evaluation happens only when\r\nnecessary. Deferred evaluation may happen multiple times, which is\r\nnecessary in many cases, but awful for performance if you do it by\r\nmistake.\r\n\r\nConsider the following definition of `every`:\r\n\r\n    every Duration, Body ->\r\n        loop\r\n            Body\r\n            sleep Duration\r\n\r\nIn that case, we want the `Body` to be evaluated every iteration,\r\nsince this is typically an operation that we want to execute at each\r\nloop. Is the same true for `Duration`?\r\n\r\nOne way to force evaluation is to give a type to the argument. If you\r\nwant to force early evaluation of the argument, and to check that it\r\nis a real value, you can do it as follows:\r\n\r\n    every Duration:real, Body ->\r\n        loop\r\n            Body\r\n            sleep Duration\r\n    \r\n### Subtlelty #4: Closures and remote transport\r\n\r\nLike many functional languages, ELIoT ensures that the value of\r\nvariables is preserved for the evaluation of a given body. Consider\r\nfor example:\r\n\r\n    adder X:integer -> (Y -> Y + X)\r\n    add3 := adder 3\r\n\r\nIn that case, `adder 3` will bind `X` to value `3`, but then the\r\nreturned value outlives the scope where `X` was declared. However, `X`\r\nis referred to in the code. So the returned value is a *closure* which\r\nintegrates the binding `X->3`.\r\n\r\nAt this point, such closures cannot be sent across a `tell`, `ask`,\r\n`invoke` or `reply`. Make sure data that is sent over to a remote node\r\nhas been evaluated before being sent.\r\n\r\n\r\n","google":"UA-26414664-6","note":"Don't delete this file! It's used internally to help with page regeneration."}