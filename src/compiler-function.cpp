// ****************************************************************************
//  compiler-function.cpp                           XL - An extensible language
// ****************************************************************************
//
//   File Description:
//
//
//
//
//
//
//
//
//
//
// ****************************************************************************
//  (C) 2018 Christophe de Dinechin <christophe@dinechin.org>
//   This software is licensed under the GNU General Public License v3
//   See LICENSE file for details.
// ****************************************************************************
// This document is released under the GNU General Public License, with the
// following clarification and exception.
//
// Linking this library statically or dynamically with other modules is making
// a combined work based on this library. Thus, the terms and conditions of the
// GNU General Public License cover the whole combination.
//
// As a special exception, the copyright holders of this library give you
// permission to link this library with independent modules to produce an
// executable, regardless of the license terms of these independent modules,
// and to copy and distribute the resulting executable under terms of your
// choice, provided that you also meet, for each linked independent module,
// the terms and conditions of the license of that module. An independent
// module is a module which is not derived from or based on this library.
// If you modify this library, you may extend this exception to your version
// of the library, but you are not obliged to do so. If you do not wish to
// do so, delete this exception statement from your version.
//
// See http://www.gnu.org/copyleft/gpl.html and Matthew 25:22 for details
//  (C) 1992-2018 Christophe de Dinechin <christophe@taodyne.com>
//  (C) 2010 Taodyne SAS
// ****************************************************************************

#include "compiler-function.h"
#include "compiler-expr.h"
#include "basics.h"
#include <stdint.h>


RECORDER(compiler_function, 64, "Functions generated by the compiler");
RECORDER(parameter_bindings, 64, "Looking up parameters in functions");

XL_BEGIN

CompilerFunction::CompilerFunction(CompilerUnit &unit,
                                   Tree *form,
                                   Tree *body,
                                   Types *types,
                                   FunctionType_p ftype,
                                   text name)
// ----------------------------------------------------------------------------
//   Create new compiler function for standard evaluation functions (eval_fn)
// ----------------------------------------------------------------------------
//  This is used for a top-level function, which is turned into an eval_fn
//  There is no closure since nothing can be captured from enclosing scope
    : CompilerPrototype(unit, form, types, ftype, name),
      compiler(unit.compiler),
      jit(unit.jit),
      body(body),
      data(jit, function, "data"),
      code(jit, function, "code"),
      exit(jit, function, "exit"),
      entry(code.Block()),
      returned(data.AllocateReturnValue(function)),
      closure(nullptr)
{
    InitializeArgs();
    record(compiler_function, "Created %p for %t in %p value %v",
           this, form, types, function);
}


CompilerFunction::CompilerFunction(CompilerFunction &caller,
                                   RewriteCandidate *rc)
// ----------------------------------------------------------------------------
//   Create new compiler function for optimized evaluation functions
// ----------------------------------------------------------------------------
//   This is used by rewrites like [Form is Body].
//   In that case, 'parms' have been generated to match [Form] free parms,
//   and we build a closure type if [Body] had captures from the environment
    : CompilerPrototype(caller, rc),
      compiler(caller.compiler),
      jit(caller.jit),
      body(rc->RewriteBody()),
      data(jit, function, "data"),
      code(jit, function, "code"),
      exit(jit, function, "exit"),
      entry(code.Block()),
      returned(data.AllocateReturnValue(function)),
      closure(nullptr)
{
    InitializeArgs(rc);
    record(compiler_function,
           "Created optimized %p called by %p for %t function %v",
           this, &caller, form, function);
}


CompilerFunction::~CompilerFunction()
// ----------------------------------------------------------------------------
//   Delete compiler function
// ----------------------------------------------------------------------------
{
    record(compiler_unit, "Deleted function %p for %t", this, form);
}


CompilerFunction::Primitives CompilerFunction::primitives;


void CompilerFunction::InitializePrimitives()
// ----------------------------------------------------------------------------
//   Initialize the primitives if the primitives table is empty
// ----------------------------------------------------------------------------
{
    if (primitives.size())
        return;

#define UNARY(Name)                                                     \
    primitives[#Name] = PrimitiveInfo {&CompilerFunction::llvm_##Name, 1};
#define BINARY(Name)                                                    \
    primitives[#Name] = PrimitiveInfo {&CompilerFunction::llvm_##Name, 2};
#define CAST(Name)                                                      \
    primitives[#Name] = PrimitiveInfo {&CompilerFunction::llvm_##Name, 2};
#define SPECIAL(Name, Arity, Code)                                      \
    primitives[#Name] = PrimitiveInfo {&CompilerFunction::llvm_##Name, Arity};
#define ALIAS(To, Arity, From)                                          \
    primitives[#To] = PrimitiveInfo {&CompilerFunction::llvm_##From, Arity};

#define EXTERNAL(Name, ...)

#include "compiler-primitives.tbl"

}


bool CompilerFunction::IsInterfaceOnly()
// ----------------------------------------------------------------------------
//   Check if the function is an interface-only function (for C calls)
// ----------------------------------------------------------------------------
{
    return entry == nullptr;
}


Function_p CompilerFunction::Compile(Tree *tree, bool force)
// ----------------------------------------------------------------------------
//    Compile a given tree in given function and return the associated value
// ----------------------------------------------------------------------------
{
    CompilerExpression expr(*this);
    Value_p result = expr.Evaluate(tree, force);
    if (returned)
        Return(tree, result);
    return function;
}


Value_p CompilerFunction::Return(Tree *tree, Value_p value)
// ----------------------------------------------------------------------------
//   Return the given value, after appropriate boxing
// ----------------------------------------------------------------------------
{
    Type_p retTy = jit.ReturnType(function);
    value = Autobox(tree, value, retTy);

    Type_p valTy = JIT::Type(value);
    if (valTy == retTy)
        code.Store(value, returned);
    return value;
}


eval_fn CompilerFunction::Finalize(bool createCode)
// ----------------------------------------------------------------------------
//   Finalize the build of the current function
// ----------------------------------------------------------------------------
{
    record(llvm, "Finalize function %v", function);

    // Branch to the exit block from the current main body of code
    code.Branch(exit);

    // Connect the "allocas" data prologue to the actual entry point
    data.Branch(entry);

    // Insert return in exit block
    if (returned)
    {
        Value_p retVal = exit.Load(returned, "retval");
        exit.Return(retVal);
    }
    else
    {
        exit.Return(nullptr);
    }

    // Verify the function we built
    if (RECORDER_TRACE(llvm_code) & 2)
        jit.Print("LLVM IR before verification and optimizations", function);
    if (jit.VerifyFunction(function))
    {
        Ooops("Generated code verification failed for $1 (internal)", form);
        return nullptr;
    }
    jit.Finalize(function);
    if (RECORDER_TRACE(llvm_code) & 4)
        jit.Print("LLVM IR after optimizations", function);

    void *result = NULL;
    if (createCode)
    {
        result = jit.ExecutableCode(function);
        if (RECORDER_TRACE(llvm_code) & 8)
            jit.Print("LLVM IR after machine code generation", function);
    }

    record(llvm_functions, "Function code %p for %v", result, function);
    return (eval_fn) result;
}


void CompilerFunction::InitializeArgs()
// ----------------------------------------------------------------------------
//   Initialize the arguments and return statements for eval functions
// ----------------------------------------------------------------------------
//   In that case, the arguments are (Scope *scope, Tree *self)
{
    // Associate the value for the additional arguments (read-only, no alloca)
    Function::arg_iterator args = function->arg_begin();
    Value_p scope = &*args++;
    Value_p self = &*args++;

    // Insert 'self', mapping to form, and 'scope' for the evaluation scope
    values[xl_scope] = scope;
    values[xl_self] = self;
}


void CompilerFunction::InitializeArgs(RewriteCandidate *rc)
// ----------------------------------------------------------------------------
//   Initialize the arguments and return statements for optimized functions
// ----------------------------------------------------------------------------
//   In that case, the arguments are from the function itself
//   They may start with a closure pointer, which we read here to have
//   the values set during the rest of the code generation
{
    // Associate the value for the additional arguments (read-only, no alloca)
    Function::arg_iterator args = function->arg_begin();

    // Read the actual parameters
    for (RewriteBinding &binding : rc->bindings)
    {
        Value_p inputArg = &*args++;
        values[binding.name] = inputArg;
    }

    // Insert 'self', mapping to form, and 'scope' for the evaluation scope
    Scope *scope = rc->vtypes->TypesScope();
    Tree *form = rc->RewriteForm();
    values[xl_scope] = data.PointerConstant(compiler.scopePtrTy, scope);
    values[xl_self] = data.PointerConstant(compiler.treePtrTy, form);
}


Value_p CompilerFunction::Compile(Tree *call,
                                  RewriteCandidate *rc,
                                  const Values &args)
// ----------------------------------------------------------------------------
//    Compile a given rewrite for a tree
// ----------------------------------------------------------------------------
{
    // Check if cache already contains a compilation for this function
    Scope *scope = types->TypesScope();
    Function_p &function = unit.Compiled(scope, rc, args);
    if (function == NULL)
    {
        Tree *body = rc->RewriteBody();

        // Check if we have C or data forms
        bool isC = false;
        bool isData = false;
        text label = rc->defined_name;

        // Case of [sin X is C]: Use the name 'sin'
        if (Name *bodyname = body->AsName())
        {
            if (bodyname->value == "C")
                if (Name *defname = rc->defined->AsName())
                    if (IsValidCName(defname, label))
                        isC = true;
            if (bodyname->value == "self")
                isData = true;
        }

        // Case of [alloc X is C "_malloc"]: Use "_malloc"
        if (Prefix *prefix = body->AsPrefix())
            if (Name *name = prefix->left->AsName())
                if (name->value == "C")
                    if (IsValidCName(prefix->right, label))
                        isC = true;


        if (isC)
        {
            CompilerPrototype proto(*this, rc);
            function = proto.Function();
        }
        else
        {
            if (isData)
            {
                Type_p retTy = rc->RewriteType();
                if (!retTy)
                {
                    retTy = StructureType(rc->RewriteSignature(),
                                          rc->RewriteForm());
                    rc->RewriteType(retTy);
                }
            }


            CompilerFunction evalfn(*this, rc);

            // Make sure we don't recompile in case of recursive evaluation
            function = evalfn.Function();

            // Compile the body
            if (!isData)
            {
                // Regular function body: compile it
                evalfn.Compile(body);
            }
            else
            {
                // Constructor for a 'data' form, e.g. [X,Y is self]
                unsigned index = 0;
                Tree *form = RewriteDefined(rc->RewriteForm());
                Value_p box = evalfn.returned;
                Value_p retv = evalfn.Data(form, box, index);
                evalfn.Return(body, retv);
            }

            evalfn.Finalize(false);
        }
    }

    return function;
}


bool CompilerFunction::IsValidCName(Tree *tree, text &label)
// ----------------------------------------------------------------------------
//   Check if the name is valid for C
// ----------------------------------------------------------------------------
{
    uint len = 0;

    if (Name *name = tree->AsName())
    {
        label = name->value;
        len = label.length();
    }
    else if (Text *text = tree->AsText())
    {
        label = text->value;
        len = label.length();
    }

    if (len == 0)
    {
        Ooops("No valid C name in $1", tree);
        return false;
    }

    // We will NOT call functions beginning with _ (internal functions)
    for (uint i = 0; i < len; i++)
    {
        char c = label[i];
        if (!isalpha(c) && c != '_' && !(i && isdigit(c)))
        {
            Ooops("C name $1 contains invalid characters", tree);
            return false;
        }
    }
    return true;
}


Value_p CompilerFunction::Data(Tree *expr, Value_p box, unsigned &index)
// ----------------------------------------------------------------------------
//    Generate a constructor for a data form, e.g. [X,Y is self]
// ----------------------------------------------------------------------------
{
    Value_p left, right, child;

    switch(expr->Kind())
    {
    case INTEGER:
    case REAL:
    case TEXT:
    {
        // For all these cases, simply compute the corresponding value
        CompilerExpression subexpr(*this);
        Value_p result = subexpr.Evaluate(expr);
        Value_p ptr = code.StructGEP(box, index++, "resultp");
        result = code.Store(result, ptr);
        return result;
    }

    case NAME:
    {
        // Bound names are returned as is, parameters are evaluated
        Context *context = types->TypesContext();
        record(parameter_bindings, "Looking up %t in context %p",
               expr, (Context *) context);
        Tree *existing = context->DeclaredForm(expr);
        assert (existing || !"TypeAnalysis didn't realize a name was missing");

        // Arguments bound here are returned directly as a tree
        if (Value_p result = Known(existing))
        {
            // Store that in the result tree
            Value_p ptr = code.StructGEP(box, index++, "resultp");
            result = code.Store(result, ptr);
            return result;
        }

        // Arguments not bound here are returned as a constant
        return ConstantTree(existing);
    }

    case INFIX:
    {
        Infix *infix = (Infix *) expr;
        left = Data(infix->left, box, index);
        right = Data(infix->right, box, index);
        return right;
    }

    case PREFIX:
    {
        Prefix *prefix = (Prefix *) expr;
        left = Data(prefix->left, box, index);
        right = Data(prefix->right, box, index);
        return right;
    }

    case POSTFIX:
    {
        Postfix *postfix = (Postfix *) expr;
        left = Data(postfix->left, box, index);
        right = Data(postfix->right, box, index);
        return right;
    }

    case BLOCK:
    {
        Block *block = (Block *) expr;
        child = Data(block->child, box, index);
        return child;
    }
    }

    assert (!"Unknown kind of tree in Data()");
    return ConstantTree(expr);
}


Value_p CompilerFunction::Autobox(Tree *source, Value_p value, Type_p req)
// ----------------------------------------------------------------------------
//   Automatically box/unbox types
// ----------------------------------------------------------------------------
//   Primitive values like integers can exist in two forms during execution:
//   - In boxed form, e.g. as a pointer to an instance of Integer
//   - In native form, e.g. as an integer
//   This function automatically converts from one to the other as necessary
{
    Type_p     type   = JIT::Type(value);
    Value_p    result = value;
    Function_p boxFn  = nullptr;

    // Short circuit if we are already there
    if (req == type)
        return result;

    // Unboxing cases
    if (req == compiler.booleanTy)
    {
        assert (type == compiler.treePtrTy || type == compiler.nameTreePtrTy);
        Value_p falsePtr = ConstantTree(xl_false);
        result = code.ICmpNE(value, falsePtr, "notfalse");
    }
    else if (req->isIntegerTy())
    {
        if (req == compiler.characterTy && type == compiler.textTreePtrTy)
        {
            // Convert text constant to character
            result = code.StructGEP(result, TEXT_VALUE_INDEX, "ubox_text");
            result = code.StructGEP(result, 0, "ubox_charpp");
            result = code.StructGEP(result, 0, "ubox_charp");
            result = code.Load(result, "ubox_char");
        }
        else
        {
            // Convert integer constants
            assert (type == compiler.integerTreePtrTy);
            result = code.StructGEP(value, INTEGER_VALUE_INDEX, "ubox_int");
            if (req != compiler.integerTy)
                result = code.Trunc(result, req);
        }
    }
    else if (req->isFloatingPointTy())
    {
        assert(type == compiler.realTreePtrTy);
        result = code.StructGEP(value, REAL_VALUE_INDEX, "ubox_real");
        if (req != compiler.realTy)
            result = code.FPTrunc(result, req);
    }
    else if (req == compiler.charPtrTy)
    {
        assert(type == compiler.textTreePtrTy);
        result = code.StructGEP(result, TEXT_VALUE_INDEX, "ubox_text");
        result = code.StructGEP(result, 0, "ubox_charpp");
        result = code.Load(result, "ubox_charp");
    }
    else if (req == compiler.textTy)
    {
        assert (type == compiler.textTreePtrTy);
        result = code.StructGEP(result, TEXT_VALUE_INDEX, "ubox_text");
    }

    // Boxing cases
    else if (type == compiler.booleanTy)
    {
        assert(req == compiler.nameTreePtrTy || req == compiler.treePtrTy);
        Value_p truep = code.PointerConstant(compiler.nameTreePtrTy, xl_true);
        Value_p falsep = code.PointerConstant(compiler.nameTreePtrTy, xl_false);
        result = code.Select(value, truep, falsep);
    }
    else if (type == compiler.characterTy &&
             (req == compiler.treePtrTy || req == compiler.textTreePtrTy))
    {
        boxFn = unit.xl_new_character;
    }
    else if (type->isIntegerTy())
    {
        assert(req == compiler.treePtrTy || req == compiler.integerTreePtrTy);
        boxFn = unit.xl_new_integer;
        if (type != compiler.ulonglongTy)
            result = code.SExt(result, compiler.ulonglongTy); // REVISIT: Sign?
    }
    else if (type->isFloatingPointTy())
    {
        assert(req == compiler.treePtrTy || req == compiler.realTreePtrTy);
        boxFn = unit.xl_new_real;
        if (type != compiler.realTy)
            result = code.FPExt(result, type);
    }
    else if (type == compiler.textTy)
    {
        assert(req == compiler.treePtrTy || req == compiler.textTreePtrTy);
        boxFn = unit.xl_new_text;
    }
    else if (type == compiler.charPtrTy)
    {
        assert(req == compiler.treePtrTy || req == compiler.textTreePtrTy);
        boxFn = unit.xl_new_ctext;
    }
    else if (req == compiler.blockTreePtrTy   ||
             req == compiler.infixTreePtrTy   ||
             req == compiler.prefixTreePtrTy  ||
             req == compiler.postfixTreePtrTy ||
             req == compiler.treePtrTy)
    {
        boxFn = unit.CompiledUnbox(type);
        if (boxFn)
        {
            Value_p storage = NeedStorage(source);
            code.Store(result, storage);
            result = storage;
        }
    }

    // If we need to invoke a boxing function, do it now
    if (boxFn)
    {
        uint64_t pos = source->Position();
        Value_p posValue = code.IntegerConstant(compiler.ulongTy, pos);
        result = code.Call(boxFn, posValue, result);
    }
    type = JIT::Type(result);

    // Check if a tree type cast is required
    if (req == compiler.treePtrTy && type != req)
    {
        if (type == compiler.integerTreePtrTy ||
            type == compiler.realTreePtrTy    ||
            type == compiler.textTreePtrTy    ||
            type == compiler.nameTreePtrTy    ||
            type == compiler.blockTreePtrTy   ||
            type == compiler.prefixTreePtrTy  ||
            type == compiler.postfixTreePtrTy ||
            type == compiler.infixTreePtrTy)
            result = code.BitCast(result, req);
        else
            // If there was some inconsistency, return an error
            result = ConstantTree(xl_nil);
    }

    // Return what we built if anything
    return result;
}


Function_p CompilerFunction::UnboxFunction(Type_p type, Tree *pattern)
// ----------------------------------------------------------------------------
//    Create a function transforming a boxed (structure) value into tree form
// ----------------------------------------------------------------------------
{
    // Check if we have a matching boxing function
    Function_p &function = unit.CompiledUnbox(type);

    if (!function)
    {
        if (Tree *inner = types->IsTypeOf(pattern))
            pattern = inner;

        // Get original form representing that data type
        Type_p mtype = compiler.treePtrTy;
        Type_p ptype = unit.jit.PointerType(type);

        // Create a function that looks like [Tree *unboxfn(boxtype *)]
        Signature sig { compiler.ulongTy, ptype };
        FunctionType_p fty = jit.FunctionType(mtype, sig);
        CompilerFunction unbox(unit, pattern, pattern, types, fty, "xl.unbox");

        // Find the first input argument, which is the boxed value pointer
        function = unbox.Function();
        auto args = function->arg_begin();
        Value_p position = &*args++; // Ignored?
        Value_p arg = &*args++;

        // Generate the code to create the unboxed tree
        unsigned index = 0;
        Value_p rval = unbox.Unbox(arg, pattern, index);
        rval = unbox.Autobox(pattern, rval, mtype);
        unbox.Return(pattern, rval);

        // Finalize the unbox function
        unbox.Finalize(false);

        record(types_boxing, "Created %T unboxing function %v for %t pos %v",
               mtype, unbox.function, pattern, position);

    }

    return function;
}


Value_p CompilerFunction::Unbox(Value_p boxed, Tree *pattern, uint &index)
// ----------------------------------------------------------------------------
//   Recursively generate code to unbox a value within UnboxFunction
// ----------------------------------------------------------------------------
{
    Type_p ttp = compiler.treePtrTy;
    Value_p ref, left, right, child;

    switch(pattern->Kind())
    {
    default:
        assert(!"Invalid tree kind in CompilerFunction::Unbox");

    case INTEGER:
    case REAL:
    case TEXT:
    {
        // Constant values in the pattern can be returned as is
        return ConstantTree(pattern);
    }

    case NAME:
    {
        // Get element from input argument
        Value_p result = code.StructGEP(boxed, index++, "boxedp");
        result = code.Load(result);
        return result;
    }

    case INFIX:
    {
        Infix *infix = (Infix *) pattern;
        if (infix->name == ":" || infix->name == "as" || infix->name == "when")
            return Unbox(boxed, infix->left, index);
        ref = ConstantTree(infix);
        ref = code.BitCast(ref, compiler.infixTreePtrTy);
        left = Unbox(boxed, infix->left, index);
        right = Unbox(boxed, infix->right, index);
        left = Autobox(infix->left, left, ttp);
        right = Autobox(infix->right, right, ttp);
        return code.Call(unit.xl_new_infix, ref, left, right);
    }

    case PREFIX:
    {
        Prefix *prefix = (Prefix *) pattern;
        ref = ConstantTree(prefix);
        ref = code.BitCast(ref, compiler.prefixTreePtrTy);
        if (prefix->left->Kind() == NAME)
            left = ConstantTree(prefix->left);
        else
            left = Unbox(boxed, prefix->left, index);
        right = Unbox(boxed, prefix->right, index);
        left = Autobox(prefix->left, left, ttp);
        right = Autobox(prefix->right, right, ttp);
        return code.Call(unit.xl_new_prefix, ref, left, right);
    }

    case POSTFIX:
    {
        Postfix *postfix = (Postfix *) pattern;
        ref = ConstantTree(postfix);
        ref = code.BitCast(ref, compiler.postfixTreePtrTy);
        left = Unbox(boxed, postfix->left, index);
        if (postfix->right->Kind() == NAME)
            right = ConstantTree(postfix->right);
        else
            right = Unbox(boxed, postfix->right, index);
        left = Autobox(postfix->left, left, ttp);
        right = Autobox(postfix->right, right, ttp);
        return code.Call(unit.xl_new_postfix, ref, left, right);
    }

    case BLOCK:
    {
        Block *block = (Block *) pattern;
        ref = ConstantTree(block);
        ref = code.BitCast(ref, compiler.blockTreePtrTy);
        child = Unbox(boxed, block->child, index);
        child = Autobox(block->child, child, ttp);
        return code.Call(unit.xl_new_block, ref, child);
    }
    }
}


Value_p CompilerFunction::NeedStorage(Tree *tree)
// ----------------------------------------------------------------------------
//    Allocate storage for a given tree
// ----------------------------------------------------------------------------
{
    Value_p result = storage[tree];
    if (!result)
    {
        // Get the associated machine type
        Type_p mtype = ValueMachineType(tree);

        // Create alloca to store the new form
        result = data.Alloca(mtype, "loc");
        storage[tree] = result;

        // If this started with a value, initialize it here
        if (values.count(tree))
        {
            Value_p initializer = values[tree];
            assert(initializer && initializer->getType() == mtype);
            code.Store(initializer, result);
        }
    }

    return result;
}


bool CompilerFunction::IsKnown(Tree *tree, uint which)
// ----------------------------------------------------------------------------
//   Check if the tree has a known local or global value
// ----------------------------------------------------------------------------
{
    if ((which & knowLocals) && storage.count(tree) > 0)
        return true;
    else if ((which & knowValues) && values.count(tree) > 0)
        return true;
    else if ((which & knowGlobals) && unit.globals.count(tree) > 0)
        return true;
    return false;
}


Value_p CompilerFunction::Known(Tree *tree, uint which)
// ----------------------------------------------------------------------------
//   Return the known local or global value if any
// ----------------------------------------------------------------------------
{
    if (which & knowLocals)
    {
        auto it = storage.find(tree);
        if (it != storage.end())
            return code.Load(it->second, "loc");
    }
    if (which & knowValues)
    {
        auto it = values.find(tree);
        if (it != values.end())
            return it->second;
    }
    if (which & knowGlobals)
    {
        auto it = unit.globals.find(tree);
        if (it != unit.globals.end())
            return code.Load(it->second, "glob");
    }
    return nullptr;
}


Value_p CompilerFunction::ConstantInteger(Integer *what)
// ----------------------------------------------------------------------------
//    Generate an Integer tree
// ----------------------------------------------------------------------------
{
    Value_p result = code.PointerConstant(compiler.integerTreePtrTy, what);
    return result;
}


Value_p CompilerFunction::ConstantReal(Real *what)
// ----------------------------------------------------------------------------
//    Generate a Real tree
// ----------------------------------------------------------------------------
{
    Value_p result = code.PointerConstant(compiler.realTreePtrTy, what);
    return result;
}


Value_p CompilerFunction::ConstantText(Text *what)
// ----------------------------------------------------------------------------
//    Generate a Text tree
// ----------------------------------------------------------------------------
{
    Value_p result = code.PointerConstant(compiler.textTreePtrTy, what);
    return result;
}


Value_p CompilerFunction::ConstantTree(Tree *what)
// ----------------------------------------------------------------------------
//    Generate a constant tree
// ----------------------------------------------------------------------------
{
    Value_p result = code.PointerConstant(compiler.treePtrTy, what);
    return result;
}


Value_p CompilerFunction::CallFormError(Tree *what)
// ----------------------------------------------------------------------------
//   Report a type error trying to evaluate some argument
// ----------------------------------------------------------------------------
{
    Value_p ptr = ConstantTree(what);
    Value_p scope = ConstantTree(types->TypesScope());
    Value_p callVal = code.Call(unit.xl_form_error, scope, ptr);
    return callVal;
}


Type_p CompilerFunction::ValueMachineType(Tree *tree)
// ----------------------------------------------------------------------------
//    Return machine type associated to a type name or expression, if any
// ----------------------------------------------------------------------------
{
    // Find the base type for the expression
    Tree *base = types->CodegenType(tree);
    if (!base)
    {
        Ooops("Internal: No type deduced for $1, using integer", tree);
        return compiler.integerTy;
    }

    // Find the corresponding machine type
    Type_p type = BoxedType(base);
    if (!type)
    {
        Ooops("Internal: No type associated to $1", tree);
        return compiler.integerTy;
    }

    return type;
}


void CompilerFunction::ValueMachineType(Tree *tree, Type_p type)
// ----------------------------------------------------------------------------
//    Record the global value associated to a type name or expression
// ----------------------------------------------------------------------------
{
    Tree *base = types->CodegenType(tree);
    AddBoxedType(base, type);
}


void CompilerFunction::AddBoxedType(Tree *type, Type_p mtype)
// ----------------------------------------------------------------------------
//   Associate a tree type to a boxed machine type
// ----------------------------------------------------------------------------
///  The tree type could be a named type, e.g. [integer], or data, e.g. [X,Y]
//   The machine type could be integerTy or StructType({integerTy, realTy})
{
    types->AddBoxedType(type, mtype);
}


Type_p CompilerFunction::HasBoxedType(Tree *type)
// ----------------------------------------------------------------------------
//   Return the boxed type if there is one
// ----------------------------------------------------------------------------
{
    Type_p result = types->BoxedType(type);
    return result;
}


Type_p CompilerFunction::BoxedType(Tree *type)
// ----------------------------------------------------------------------------
//   Return the machine "boxed" type for a given tree type
// ----------------------------------------------------------------------------
{
    // Check if we already had it
    Type_p mtype = types->BoxedType(type);
    if (mtype)
        return mtype;
    Tree *base = types->BaseType(type);
    Context *context = types->TypesContext();

    // Check if we have one of the basic types
#define CTYPE(name, cty)        if (base==name##_type) mtype = compiler.cty##Ty
#define STYPE(name)             CTYPE(name, name)
#define TTYPE(name)             CTYPE(name, name##TreePtr)

    // Check types for constants
    switch(type->Kind())
    {
    case INTEGER:
        mtype = compiler.integerTy;
        base = integer_type;
        break;
    case REAL:
        mtype = compiler.realTy;
        base = real_type;
        break;
    case TEXT:
        if (((Text *)type)->IsCharacter())
        {
            mtype = compiler.characterTy;
            base = character_type;
        }
        else
        {
            mtype = compiler.charPtrTy;
            base = text_type;
        }
        break;
    case NAME:
        if (Tree *declared = context->DeclaredForm(type))
            if (declared != base)
                base = declared;

        if (base == xl_true || base == xl_false)
        {
            mtype = compiler.booleanTy;
            base = boolean_type;
        }
        if (base == xl_nil)
            mtype = compiler.voidTy;
        if (base == xl_error)
            mtype = compiler.treePtrTy;
        STYPE(boolean);
        STYPE(integer);
        STYPE(integer8);
        STYPE(integer16);
        STYPE(integer32);
        STYPE(integer64);
        STYPE(unsigned);
        CTYPE(unsigned8,        integer8);
        CTYPE(unsigned16,       integer16);
        CTYPE(unsigned32,       integer32);
        CTYPE(unsigned64,       integer64);
        STYPE(character);
        CTYPE(text,             charPtr);
        STYPE(real);
        STYPE(real32);
        STYPE(real64);
        CTYPE(tree,             treePtr);
        CTYPE(value,            treePtr);
        CTYPE(name,             nameTreePtr);
        CTYPE(symbol,           nameTreePtr);
        CTYPE(operator,         nameTreePtr);
        TTYPE(infix);
        CTYPE(declaration,      infixTreePtr);
        TTYPE(prefix);
        TTYPE(postfix);
        TTYPE(block);
        break;

    case INFIX:
        if (Infix *range = types->IsRangeType(type))
            mtype = BoxedType(range->left);
        break;

    case PREFIX:
        break;

    case POSTFIX:
        break;

    case BLOCK:
        if (Block *block = (Block *) type)
            mtype = BoxedType(block->child);
        break;
    }

    if (mtype)
        types->AddBoxedType(type, mtype);

    return mtype;
}


Type_p CompilerFunction::ReturnType(Tree *parmForm)
// ----------------------------------------------------------------------------
//   Compute the return type associated with the given form
// ----------------------------------------------------------------------------
{
    // Type inference gives us the return type for this form
    Tree *type = types->CodegenType(parmForm);
    Type_p mtype = BoxedType(type);
    if (!mtype)
        mtype = jit.VoidType();
    return mtype;
}


Type_p CompilerFunction::StructureType(const Signature &signature, Tree *rwform)
// ----------------------------------------------------------------------------
//   Compute the return type associated with a data form
// ----------------------------------------------------------------------------
{
    Tree *base = types->CodegenType(rwform);
    if (Type_p mtype = HasBoxedType(base))
        return mtype;

    // Build the corresponding structure type
    StructType_p stype = jit.StructType(signature, "boxed");

    // Record boxing and unboxing for that particular tree
    AddBoxedType(base, stype);
    UnboxFunction(stype, rwform);

    return stype;
}


Value_p CompilerFunction::BoxedTree(Tree *what)
// ----------------------------------------------------------------------------
//   Compute a boxed tree value
// ----------------------------------------------------------------------------
{
    if (Name *name = what->AsName())
    {
        Context *context = types->TypesContext();
        what = context->Bound(name);
    }

    // Compute the boxed type for the data
    Signature sig;
    BoxedTreeType(sig, what);
    Type_p sty = StructureType(sig, what);
    record(compiler_function, "Boxed tree %t is type %v", what, sty);

    // Generate the data
    unsigned index = 0;
    Value_p box = NeedStorage(what);
    Value_p result = Data(what, box, index);

    result = code.Load(box);
    return result;
}


void CompilerFunction::BoxedTreeType(Signature &sig, Tree *what)
// ----------------------------------------------------------------------------
//  Compute the signature for a boxed tree
// ----------------------------------------------------------------------------
{
    switch(what->Kind())
    {
    case INTEGER:
    case REAL:
    case TEXT:
        sig.push_back(ValueMachineType(what));
        break;

    case NAME:
        what = types->TypesContext()->DeclaredForm(what);
        sig.push_back(ValueMachineType(what));
        break;

    case BLOCK:
        BoxedTreeType(sig, ((Block *) what)->child);
        break;
    case PREFIX:
        BoxedTreeType(sig, ((Prefix *) what)->left);
        BoxedTreeType(sig, ((Prefix *) what)->right);
        break;
    case POSTFIX:
        BoxedTreeType(sig, ((Postfix *) what)->left);
        BoxedTreeType(sig, ((Postfix *) what)->right);
        break;
    case INFIX:
        BoxedTreeType(sig, ((Infix *) what)->left);
        BoxedTreeType(sig, ((Infix *) what)->right);
        break;
    }
}


Value_p CompilerFunction::Primitive(Tree *what,
                                    text name,
                                    uint arity,
                                    Value_p *args)
// ----------------------------------------------------------------------------
//   Invoke an LLVM primitive, assuming it's found in the table
// ----------------------------------------------------------------------------
{
    // Find the entry in the primitives table
    auto found = primitives.find(name);
    if (found == primitives.end())
    {
        Ooops("Invalid primitive $1", what);
        return ConstantTree(what);
    }

    // If the entry doesn't have the expected arity, give up
    PrimitiveInfo &primitive = (*found).second;
    if (primitive.arity != arity)
    {
        Ooops("Primitive  arity for $1 is wrong, should be $2", what)
            .Arg(primitive.arity);
        return ConstantTree(what);
    }

    // Invoke the entry
    Value_p result = (this->*primitive.function)(what, args);
    return result;
}



// ============================================================================
//
//   Define all the LLVM wrappers
//
// ============================================================================

#define UNARY(Name)                                                     \
Value_p CompilerFunction::llvm_##Name(Tree *source, Value_p *args)      \
{                                                                       \
    return code.Name(args[0]);                                          \
}

#define BINARY(Name)                                                    \
Value_p CompilerFunction::llvm_##Name(Tree *source, Value_p *args)      \
{                                                                       \
    return code.Name(args[0], args[1]);                                 \
}

#define CAST(Name)                                                      \
Value_p CompilerFunction::llvm_##Name(Tree *source, Value_p *args)      \
{                                                                       \
    return code.Name(args[0], (Type_p) args[1]);                        \
}


#define SPECIAL(Name, Arity, Code)                                      \
Value_p CompilerFunction::llvm_##Name(Tree *source, Value_p *args)      \
{                                                                       \
    Code;                                                               \
}

#define ALIAS(from, arity, to)
#define EXTERNAL(Name, ...)

#include "compiler-primitives.tbl"



// ============================================================================
//
//    Compiler evaluation function
//
// ============================================================================

CompilerEval::CompilerEval(CompilerUnit &unit,
                           Tree *body,
                           Types *types)
// ----------------------------------------------------------------------------
//   Build a compiler eval function
// ----------------------------------------------------------------------------
    : CompilerFunction(unit, body, body, types, unit.compiler.evalTy, "xl.eval")
{
    InitializePrimitives();
    record(compiler_function, "Created evaluation %p for %t in %p as %v",
           this, body, types, function);
}

XL_END
