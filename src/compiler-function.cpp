// ****************************************************************************
//  compiler-function.cpp                           XL - An extensible language
// ****************************************************************************
//
//   File Description:
//
//
//
//
//
//
//
//
//
//
// ****************************************************************************
//  (C) 2018 Christophe de Dinechin <christophe@dinechin.org>
//   This software is licensed under the GNU General Public License v3
//   See LICENSE file for details.
// ****************************************************************************
// This document is released under the GNU General Public License, with the
// following clarification and exception.
//
// Linking this library statically or dynamically with other modules is making
// a combined work based on this library. Thus, the terms and conditions of the
// GNU General Public License cover the whole combination.
//
// As a special exception, the copyright holders of this library give you
// permission to link this library with independent modules to produce an
// executable, regardless of the license terms of these independent modules,
// and to copy and distribute the resulting executable under terms of your
// choice, provided that you also meet, for each linked independent module,
// the terms and conditions of the license of that module. An independent
// module is a module which is not derived from or based on this library.
// If you modify this library, you may extend this exception to your version
// of the library, but you are not obliged to do so. If you do not wish to
// do so, delete this exception statement from your version.
//
// See http://www.gnu.org/copyleft/gpl.html and Matthew 25:22 for details
//  (C) 1992-2018 Christophe de Dinechin <christophe@taodyne.com>
//  (C) 2010 Taodyne SAS
// ****************************************************************************

#include "compiler-function.h"
#include "compiler-expr.h"
#include "basics.h"
#include <stdint.h>


RECORDER(compiler_function, 64, "Functions generated by the compiler");
RECORDER(parameter_bindings, 64, "Looking up parameters in functions");
RECORDER(boxed_types, 64, "Boxed machine types associated to XL types");

XL_BEGIN

CompilerFunction::CompilerFunction(CompilerUnit &unit,
                                   Scope *scope,
                                   Tree *source,
                                   FunctionType_p type)
// ----------------------------------------------------------------------------
//   Create new compiler function for standard evaluation functions (eval_fn)
// ----------------------------------------------------------------------------
//  This is used for a top-level function, which is turned into an eval_fn
//  There is no closure since nothing can be captured from enclosing scope
    : unit(unit),
      compiler(unit.compiler),
      jit(unit.jit),
      context(new Context(scope)),
      form(nullptr),
      source(source),
      closureTy(nullptr),
      function(jit.Function(type, "xl.eval")),
      data(jit, function, "data"),
      code(jit, function, "code"),
      exit(jit, function, "exit"),
      entry(code.Block()),
      returned(data.AllocateReturnValue(function))
{
    InitializePrimitives();
    InitializeArgs();
    record(compiler_function, "Created eval %p with scope %t type %T",
           this, scope, type);
}


CompilerFunction::CompilerFunction(CompilerFunction &caller,
                                   Scope *scope,
                                   Tree *form,
                                   Tree *body,
                                   text name,
                                   Type_p ret,
                                   const Parameters &parms)
// ----------------------------------------------------------------------------
//   Create new compiler function for optimized evaluation functions
// ----------------------------------------------------------------------------
//   This is used by rewrites like [Form is Body].
//   In that case, 'parms' have been generated to match [Form] free parms,
//   and we build a closure type if [Body] had captures from the environment
    : unit(caller.unit),
      compiler(unit.compiler),
      jit(unit.jit),
      context(new Context(scope)),
      form(form),
      source(body),
      mty(caller.mty),
      closureTy(ClosureType(form)),
      function(OptimizedFunction(name, ret, parms)),
      data(jit, function, "data"),
      code(jit, function, "code"),
      exit(jit, function, "exit"),
      entry(code.Block()),
      returned(data.AllocateReturnValue(function))
{
    InitializeArgs(parms);
    record(compiler_function, "Created opt %p for %t in scope %t",
           this, source, scope);
}


CompilerFunction::CompilerFunction(CompilerFunction &caller,
                                   Scope *scope,
                                   Tree *form,
                                   text name,
                                   Type_p ret,
                                   const Parameters &parms)
// ----------------------------------------------------------------------------
//   Create new interface function for a C function
// ----------------------------------------------------------------------------
//   This is used by rewrites to interface to C code, i.e. [C strcmp]
    : unit(caller.unit),
      compiler(unit.compiler),
      jit(unit.jit),
      context(new Context(scope)),
      form(form),
      source(form),
      mty(caller.mty),           // Inherit machine info
      closureTy(nullptr),
      function(OptimizedFunction(name, ret, parms)),
      data(jit),
      code(jit),
      exit(jit),
      entry(nullptr),
      returned(nullptr)
{
    InitializePrimitives();
    InitializeArgs(parms);
    record(compiler_function, "Created external %p for %t in scope %t",
           this, source, scope);
}


CompilerFunction::CompilerFunction(CompilerFunction &caller,
                                   Scope *scope,
                                   Tree *form,
                                   text name, Type_p ret, const Signature &sig)
// ----------------------------------------------------------------------------
//   Create a new function with given signature
// ----------------------------------------------------------------------------
//   This is used for example when generating unbox functions
    : unit(caller.unit),
      compiler(unit.compiler),
      jit(unit.jit),
      context(new Context(scope)),
      form(form),
      source(form),
      mty(caller.mty),           // Inherit machine info
      closureTy(nullptr),
      function(jit.Function(jit.FunctionType(ret, sig), name)),
      data(jit, function, "data"),
      code(jit, function, "code"),
      exit(jit, function, "exit"),
      entry(code.Block()),
      returned(data.AllocateReturnValue(function))
{
    InitializePrimitives();
    record(compiler_function, "Created sys %p for %t in scope %t",
           this, source, scope);
}


CompilerFunction::~CompilerFunction()
// ----------------------------------------------------------------------------
//   Delete compiler function
// ----------------------------------------------------------------------------
{
    record(compiler_unit, "Deleted function %p for %t", this, source);
}


CompilerFunction::Primitives CompilerFunction::primitives;


void CompilerFunction::InitializePrimitives()
// ----------------------------------------------------------------------------
//   Initialize the primitives if the primitives table is empty
// ----------------------------------------------------------------------------
{
    if (primitives.size())
        return;

#define UNARY(Name)                                                     \
    primitives[#Name] = PrimitiveInfo {&CompilerFunction::llvm_##Name, 1};
#define BINARY(Name)                                                    \
    primitives[#Name] = PrimitiveInfo {&CompilerFunction::llvm_##Name, 2};
#define CAST(Name)                                                      \
    primitives[#Name] = PrimitiveInfo {&CompilerFunction::llvm_##Name, 2};
#define SPECIAL(Name, Arity, Code)                                      \
    primitives[#Name] = PrimitiveInfo {&CompilerFunction::llvm_##Name, Arity};
#define ALIAS(To, Arity, From)                                          \
    primitives[#To] = PrimitiveInfo {&CompilerFunction::llvm_##From, Arity};

#define EXTERNAL(Name, ...)

#include "compiler-primitives.tbl"

}


Function_p CompilerFunction::Function()
// ----------------------------------------------------------------------------
//   The LLVM function associated with the function
// ----------------------------------------------------------------------------
{
    return function;
}


bool CompilerFunction::IsInterfaceOnly()
// ----------------------------------------------------------------------------
//   Check if the function is an interface-only function (for C calls)
// ----------------------------------------------------------------------------
{
    return entry == nullptr;
}


Scope *CompilerFunction::FunctionScope()
// ----------------------------------------------------------------------------
//   The declaration scope associated with the function
// ----------------------------------------------------------------------------
{
    return context->CurrentScope();
}


Context *CompilerFunction::FunctionContext()
// ----------------------------------------------------------------------------
//   The declaration context for the function
// ----------------------------------------------------------------------------
{
    return context;
}


Function_p CompilerFunction::Compile(Tree *tree, bool force)
// ----------------------------------------------------------------------------
//    Compile a given tree in given function and return the associated value
// ----------------------------------------------------------------------------
{
    CompilerExpression expr(*this);
    Value_p result = expr.Evaluate(tree, force);
    if (returned)
        Return(tree, result);
    return function;
}


Value_p CompilerFunction::Return(Tree *tree, Value_p value)
// ----------------------------------------------------------------------------
//   Return the given value, after appropriate boxing
// ----------------------------------------------------------------------------
{
    Type_p retTy = jit.ReturnType(function);
    value = Autobox(tree, value, retTy);

    Type_p valTy = JIT::Type(value);
    if (valTy == retTy)
        code.Store(value, returned);
    return value;
}


eval_fn CompilerFunction::Finalize(bool createCode)
// ----------------------------------------------------------------------------
//   Finalize the build of the current function
// ----------------------------------------------------------------------------
{
    record(llvm, "Finalize function %v", function);

    // Branch to the exit block from the current main body of code
    code.Branch(exit);

    // Connect the "allocas" data prologue to the actual entry point
    data.Branch(entry);

    // Insert return in exit block
    if (returned)
    {
        Value_p retVal = exit.Load(returned, "retval");
        exit.Return(retVal);
    }
    else
    {
        exit.Return(nullptr);
    }

    // Verify the function we built
    if (RECORDER_TRACE(llvm_code) & 2)
        jit.Print("LLVM IR before verification and optimizations", function);
    if (jit.VerifyFunction(function))
    {
        Ooops("Generated code verification failed for $1 (internal)", source);
        return nullptr;
    }
    jit.Finalize(function);
    if (RECORDER_TRACE(llvm_code) & 4)
        jit.Print("LLVM IR after optimizations", function);

    void *result = NULL;
    if (createCode)
    {
        result = jit.ExecutableCode(function);
        if (RECORDER_TRACE(llvm_code) & 8)
            jit.Print("LLVM IR after machine code generation", function);
    }

    record(llvm_functions, "Function code %p for %v", result, function);
    return (eval_fn) result;
}


Function_p CompilerFunction::OptimizedFunction(text name,
                                               Type_p ret,
                                               const Parameters &parms)
// ----------------------------------------------------------------------------
//   Create an "optimized" function when we know the parameters
// ----------------------------------------------------------------------------
{
    // Create a signature that begins with closure if needed, then parms
    Signature signature;
    if (closureTy)
    {
        PointerType_p ptr = jit.PointerType(closureTy);
        signature.push_back(ptr);
    }
    for (auto &parm : parms)
    {
        signature.push_back(parm.type);
    }

    // Create the function with that signature
    FunctionType_p ft = jit.FunctionType(ret, signature);
    Function_p f = jit.Function(ft, name);
    record(compiler_function, "Function %v type %T closure %v",
           f, ft, closureTy);
    return f;
}


void CompilerFunction::InitializeArgs()
// ----------------------------------------------------------------------------
//   Initialize the arguments and return statements for eval functions
// ----------------------------------------------------------------------------
//   In that case, the arguments are (Scope *scope, Tree *self)
{
    // Associate the value for the additional arguments (read-only, no alloca)
    Function::arg_iterator args = function->arg_begin();
    Value_p scope = &*args++;
    Value_p self = &*args++;

    // Insert 'self', mapping to form, and 'scope' for the evaluation scope
    Types *types = unit.types;
    MachineTypes &m = mty[types];
    m.values[xl_scope] = scope;
    m.values[xl_self] = self;
}


void CompilerFunction::InitializeArgs(const Parameters &parms)
// ----------------------------------------------------------------------------
//   Initialize the arguments and return statements for optimized functions
// ----------------------------------------------------------------------------
//   In that case, the arguments are from the function itself
//   They may start with a closure pointer, which we read here to have
//   the values set during the rest of the code generation
{
    // Associate the value for the additional arguments (read-only, no alloca)
    Function::arg_iterator args = function->arg_begin();
    Types *types = unit.types;

    // If we had closure information, finish building the closure type
    // then read the closure content and initialize values[] with it
    if (closureTy)
    {
        TreeList captured;
        bool capt = types->HasCaptures(form, captured);
        assert(capt && captured.size() && "Where are the captured items?");

        // First item in closure is the pointer to the closure fn
        Type_p fnTy = function->getType();
        Signature sig { jit.PointerType(fnTy) };

        // Loop over actual captured items and add them to closure type
        for (Tree *tree : captured)
        {
            Type_p type = ValueMachineType(tree);
            sig.push_back(type);
        }
        closureTy = jit.StructType(closureTy, sig);

        // Load the elements from the closure during function data prologue
        Value_p closureArg = &*args++;
        unsigned field = 1;     // Start at #1 since 0 is function ptr
        for (Tree *tree : captured)
        {
            Value_p storage = NeedStorage(tree);
            Value_p ptr = data.StructGEP(closureArg, field++, "closure_in");
            Value_p input = data.Load(ptr);
            data.Store(input, storage);
        }
    }

    // Then read the actual parameters
    MachineTypes &m = mty[types];
    for (auto &parm : parms)
    {
        Value_p inputArg = &*args++;
        m.values[parm.name] = inputArg;
    }

    // Insert 'self', mapping to form, and 'scope' for the evaluation scope
    Scope *scope = context->CurrentScope();
    m.values[xl_scope] = data.PointerConstant(compiler.scopePtrTy, scope);
    m.values[xl_self] = data.PointerConstant(compiler.treePtrTy, form);
}


Value_p CompilerFunction::Compile(Tree *call,
                                  RewriteCandidate *rc,
                                  const Values &args)
// ----------------------------------------------------------------------------
//    Compile a given rewrite for a tree
// ----------------------------------------------------------------------------
{
    // Check if cache already contains a compilation for this function
    Scope *scope = context->CurrentScope();
    Function_p &function = unit.Compiled(scope, rc, args);
    if (function == NULL)
    {
        Rewrite *rewrite = rc->rewrite;
        CompilerFunction *rewriteFunction = RewriteFunction(rc);

        // Make sure we don't recompile in case of recursive evaluation
        function = rewriteFunction->Function();

        // Compile the body
        record(parameter_bindings,
               "Selecting context %p from candidate %p for evaluation",
               (Context *) rc->context, &rc);
        Save<Context_p> fnContext(rewriteFunction->context, rc->context);
        Tree *value = rewrite->right;
        if (!rewriteFunction->IsInterfaceOnly())
        {
            bool data = false;
            if (Name *self = value->AsName())
                if (self->value == "self")
                    data = true;
            if (!data)
            {
                // Regular function body: compile it
                rewriteFunction->Compile(value);
            }
            else
            {
                // Constructor for a 'data' form, e.g. [X,Y is self]
                unsigned index = 0;
                Tree *form = RewriteDefined(rewrite->left);
                Value_p box = rewriteFunction->returned;
                Value_p retv = rewriteFunction->Data(form, box, index);
                rewriteFunction->Return(value, retv);
            }

            rewriteFunction->Finalize(false);
            function = rewriteFunction->Function();
        }
    }

    return function;
}


Value_p CompilerFunction::Data(Tree *expr, Value_p box, unsigned &index)
// ----------------------------------------------------------------------------
//    Generate a constructor for a data form, e.g. [X,Y is self]
// ----------------------------------------------------------------------------
{
    Value_p left, right, child;

    switch(expr->Kind())
    {
    case INTEGER:
    case REAL:
    case TEXT:
    {
        // For all these cases, simply compute the corresponding value
        CompilerExpression subexpr(*this);
        Value_p result = subexpr.Evaluate(expr);
        Value_p ptr = code.StructGEP(box, index++, "resultp");
        result = code.Store(result, ptr);
        return result;
    }

    case NAME:
    {
        // Bound names are returned as is, parameters are evaluated
        record(parameter_bindings, "Looking up %t in context %p",
               expr, (Context *) context);
        Tree *existing = context->DeclaredForm(expr);
        assert (existing || !"TypeAnalysis didn't realize a name was missing");

        // Arguments bound here are returned directly as a tree
        if (Value_p result = Known(existing))
        {
            // Store that in the result tree
            Value_p ptr = code.StructGEP(box, index++, "resultp");
            result = code.Store(result, ptr);
            return result;
        }

        // Arguments not bound here are returned as a constant
        return ConstantTree(existing);
    }

    case INFIX:
    {
        Infix *infix = (Infix *) expr;
        left = Data(infix->left, box, index);
        right = Data(infix->right, box, index);
        return right;
    }

    case PREFIX:
    {
        Prefix *prefix = (Prefix *) expr;
        left = Data(prefix->left, box, index);
        right = Data(prefix->right, box, index);
        return right;
    }

    case POSTFIX:
    {
        Postfix *postfix = (Postfix *) expr;
        left = Data(postfix->left, box, index);
        right = Data(postfix->right, box, index);
        return right;
    }

    case BLOCK:
    {
        Block *block = (Block *) expr;
        child = Data(block->child, box, index);
        return child;
    }
    }

    assert (!"Unknown kind of tree in Data()");
    return ConstantTree(expr);
}


Value_p CompilerFunction::Autobox(Tree *source, Value_p value, Type_p req)
// ----------------------------------------------------------------------------
//   Automatically box/unbox types
// ----------------------------------------------------------------------------
//   Primitive values like integers can exist in two forms during execution:
//   - In boxed form, e.g. as a pointer to an instance of Integer
//   - In native form, e.g. as an integer
//   This function automatically converts from one to the other as necessary
{
    Type_p     type   = JIT::Type(value);
    Value_p    result = value;
    Function_p boxFn  = nullptr;

    // Short circuit if we are already there
    if (req == type)
        return result;

    // Unboxing cases
    if (req == compiler.booleanTy)
    {
        assert (type == compiler.treePtrTy || type == compiler.nameTreePtrTy);
        Value_p falsePtr = ConstantTree(xl_false);
        result = code.ICmpNE(value, falsePtr, "notfalse");
    }
    else if (req->isIntegerTy())
    {
        if (req == compiler.characterTy && type == compiler.textTreePtrTy)
        {
            // Convert text constant to character
            result = code.StructGEP(result, TEXT_VALUE_INDEX, "ubox_text");
            result = code.StructGEP(result, 0, "ubox_charpp");
            result = code.StructGEP(result, 0, "ubox_charp");
            result = code.Load(result, "ubox_char");
        }
        else
        {
            // Convert integer constants
            assert (type == compiler.integerTreePtrTy);
            result = code.StructGEP(value, INTEGER_VALUE_INDEX, "ubox_int");
            if (req != compiler.integerTy)
                result = code.Trunc(result, req);
        }
    }
    else if (req->isFloatingPointTy())
    {
        assert(type == compiler.realTreePtrTy);
        result = code.StructGEP(value, REAL_VALUE_INDEX, "ubox_real");
        if (req != compiler.realTy)
            result = code.FPTrunc(result, req);
    }
    else if (req == compiler.charPtrTy)
    {
        assert(type == compiler.textTreePtrTy);
        result = code.StructGEP(result, TEXT_VALUE_INDEX, "ubox_text");
        result = code.StructGEP(result, 0, "ubox_charpp");
        result = code.Load(result, "ubox_charp");
    }
    else if (req == compiler.textTy)
    {
        assert (type == compiler.textTreePtrTy);
        result = code.StructGEP(result, TEXT_VALUE_INDEX, "ubox_text");
    }

    // Boxing cases
    else if (type == compiler.booleanTy)
    {
        assert(req == compiler.nameTreePtrTy || req == compiler.treePtrTy);
        Value_p truep = code.PointerConstant(compiler.nameTreePtrTy, xl_true);
        Value_p falsep = code.PointerConstant(compiler.nameTreePtrTy, xl_false);
        result = code.Select(value, truep, falsep);
    }
    else if (type == compiler.characterTy &&
             (req == compiler.treePtrTy || req == compiler.textTreePtrTy))
    {
        boxFn = unit.xl_new_character;
    }
    else if (type->isIntegerTy())
    {
        assert(req == compiler.treePtrTy || req == compiler.integerTreePtrTy);
        boxFn = unit.xl_new_integer;
        if (type != compiler.ulonglongTy)
            result = code.SExt(result, compiler.ulonglongTy); // REVISIT: Sign?
    }
    else if (type->isFloatingPointTy())
    {
        assert(req == compiler.treePtrTy || req == compiler.realTreePtrTy);
        boxFn = unit.xl_new_real;
        if (type != compiler.realTy)
            result = code.FPExt(result, type);
    }
    else if (type == compiler.textTy)
    {
        assert(req == compiler.treePtrTy || req == compiler.textTreePtrTy);
        boxFn = unit.xl_new_text;
    }
    else if (type == compiler.charPtrTy)
    {
        assert(req == compiler.treePtrTy || req == compiler.textTreePtrTy);
        boxFn = unit.xl_new_ctext;
    }
    else if (req == compiler.blockTreePtrTy   ||
             req == compiler.infixTreePtrTy   ||
             req == compiler.prefixTreePtrTy  ||
             req == compiler.postfixTreePtrTy ||
             req == compiler.treePtrTy)
    {
        boxFn = unit.CompiledUnbox(type);
        if (boxFn)
        {
            Value_p storage = NeedStorage(source);
            code.Store(result, storage);
            result = storage;
        }
    }

    // If we need to invoke a boxing function, do it now
    if (boxFn)
    {
        uint64_t pos = source->Position();
        Value_p posValue = code.IntegerConstant(compiler.ulongTy, pos);
        result = code.Call(boxFn, posValue, result);
    }
    type = JIT::Type(result);

    // Check if a tree type cast is required
    if (req == compiler.treePtrTy && type != req)
    {
        if (type == compiler.integerTreePtrTy ||
            type == compiler.realTreePtrTy    ||
            type == compiler.textTreePtrTy    ||
            type == compiler.nameTreePtrTy    ||
            type == compiler.blockTreePtrTy   ||
            type == compiler.prefixTreePtrTy  ||
            type == compiler.postfixTreePtrTy ||
            type == compiler.infixTreePtrTy)
            result = code.BitCast(result, req);
        else
            // If there was some inconsistency, return an error
            result = ConstantTree(xl_nil);
    }

    // Return what we built if anything
    return result;
}


Function_p CompilerFunction::UnboxFunction(Type_p type, Tree *pattern)
// ----------------------------------------------------------------------------
//    Create a function transforming a boxed (structure) value into tree form
// ----------------------------------------------------------------------------
{
    // Check if we have a matching boxing function
    Function_p &function = unit.CompiledUnbox(type);

    if (!function)
    {
        Types *types = unit.types;
        if (Tree *inner = types->IsTypeOf(pattern))
            pattern = inner;

        // Get original form representing that data type
        Type_p mtype = compiler.treePtrTy;
        Type_p ptype = unit.jit.PointerType(type);

        // Create a function that looks like [Tree *unboxfn(boxtype *)]
        Scope *scope = context->CurrentScope();
        Signature sig { compiler.ulongTy, ptype };
        CompilerFunction unbox(*this, scope, pattern, "xl.unbox", mtype, sig);

        // Find the first input argument, which is the boxed value pointer
        function = unbox.Function();
        auto args = function->arg_begin();
        Value_p position = &*args++; // Ignored?
        Value_p arg = &*args++;

        // Generate the code to create the unboxed tree
        unsigned index = 0;
        Value_p rval = unbox.Unbox(arg, pattern, index);
        rval = unbox.Autobox(pattern, rval, mtype);
        unbox.Return(pattern, rval);

        // Finalize the unbox function
        unbox.Finalize(false);

        record(boxed_types, "Created %T unboxing function %v for %t pos %v",
               mtype, unbox.function, pattern, position);

    }

    return function;
}


Value_p CompilerFunction::Unbox(Value_p boxed, Tree *pattern, uint &index)
// ----------------------------------------------------------------------------
//   Recursively generate code to unbox a value within UnboxFunction
// ----------------------------------------------------------------------------
{
    Type_p ttp = compiler.treePtrTy;
    Value_p ref, left, right, child;

    switch(pattern->Kind())
    {
    default:
        assert(!"Invalid tree kind in CompilerFunction::Unbox");

    case INTEGER:
    case REAL:
    case TEXT:
    {
        // Constant values in the pattern can be returned as is
        return ConstantTree(pattern);
    }

    case NAME:
    {
        // Get element from input argument
        Value_p result = code.StructGEP(boxed, index++, "boxedp");
        result = code.Load(result);
        return result;
    }

    case INFIX:
    {
        Infix *infix = (Infix *) pattern;
        if (infix->name == ":" || infix->name == "as" || infix->name == "when")
            return Unbox(boxed, infix->left, index);
        ref = ConstantTree(infix);
        ref = code.BitCast(ref, compiler.infixTreePtrTy);
        left = Unbox(boxed, infix->left, index);
        right = Unbox(boxed, infix->right, index);
        left = Autobox(infix->left, left, ttp);
        right = Autobox(infix->right, right, ttp);
        return code.Call(unit.xl_new_infix, ref, left, right);
    }

    case PREFIX:
    {
        Prefix *prefix = (Prefix *) pattern;
        ref = ConstantTree(prefix);
        ref = code.BitCast(ref, compiler.prefixTreePtrTy);
        if (prefix->left->Kind() == NAME)
            left = ConstantTree(prefix->left);
        else
            left = Unbox(boxed, prefix->left, index);
        right = Unbox(boxed, prefix->right, index);
        left = Autobox(prefix->left, left, ttp);
        right = Autobox(prefix->right, right, ttp);
        return code.Call(unit.xl_new_prefix, ref, left, right);
    }

    case POSTFIX:
    {
        Postfix *postfix = (Postfix *) pattern;
        ref = ConstantTree(postfix);
        ref = code.BitCast(ref, compiler.postfixTreePtrTy);
        left = Unbox(boxed, postfix->left, index);
        if (postfix->right->Kind() == NAME)
            right = ConstantTree(postfix->right);
        else
            right = Unbox(boxed, postfix->right, index);
        left = Autobox(postfix->left, left, ttp);
        right = Autobox(postfix->right, right, ttp);
        return code.Call(unit.xl_new_postfix, ref, left, right);
    }

    case BLOCK:
    {
        Block *block = (Block *) pattern;
        ref = ConstantTree(block);
        ref = code.BitCast(ref, compiler.blockTreePtrTy);
        child = Unbox(boxed, block->child, index);
        child = Autobox(block->child, child, ttp);
        return code.Call(unit.xl_new_block, ref, child);
    }
    }
}


Value_p CompilerFunction::NamedClosure(Name *name, Tree *expr)
// ----------------------------------------------------------------------------
//    Compile code to pass a given tree as a closure
// ----------------------------------------------------------------------------
//    Closures are represented as functions taking a pointer to a structure
//    that will contain the values being used by the closure code
{
    Scope *scope = context->CurrentScope();
    Function_p &function = unit.CompiledClosure(scope, expr);
    if (!function)
    {
        // Figure out the return type and function type
        Types *types = unit.types;
        Tree *rtype = types->ValueType(expr);
        Type_p retTy = BoxedType(rtype);
        PointerType_p closurePtrTy = jit.PointerType(closureTy);
        Signature sig { closurePtrTy };
        CompilerFunction closure(*this, scope, expr, "xl.closure", retTy, sig);
        function = closure.Function();
        closure.Compile(expr);
        closure.Finalize(false);
    }

    // Allocate a local structure to pass as the closure
    Type_p closureType = ClosureType(name);
    Value_p closureData = data.Alloca(closureType);

    // First, store the function pointer
    uint field = 0;
    Value_p fptr = code.StructGEP(closureData, field++, "closurep");
    code.Store(function, fptr);

    // Then loop over all values that were detected while evaluating expr
    Types *types = unit.types;
    TreeList captured;
    types->HasCaptures(expr, captured);
    for (Tree *subexpr : captured)
    {
        Value_p subval = Known(subexpr);
        fptr = code.StructGEP(closureData, field++, "closureitem");
        code.Store(subval, fptr);
    }

    // Return the stack pointer that we'll use later to evaluate the closure
    return closureData;
}


StructType_p CompilerFunction::ClosureType(Tree *form)
// ----------------------------------------------------------------------------
//    Check if we need a closure type, and if so, create and record it
// ----------------------------------------------------------------------------
{
    Types *types = unit.types;
    StructType_p ctype = nullptr;
    TreeList captured;
    if (types->HasCaptures(form, captured))
    {
        ctype = jit.OpaqueType("xl.closure");
        unit.AddClosureType(ctype);
        ValueMachineType(form, ctype);
    }
    return ctype;
}


Value_p CompilerFunction::InvokeClosure(Value_p result, Value_p fnPtr)
// ----------------------------------------------------------------------------
//   Invoke a closure with a known closure function
// ----------------------------------------------------------------------------
{
    result = code.Call(fnPtr, result);
    return result;
}


Value_p CompilerFunction::InvokeClosure(Value_p result)
// ----------------------------------------------------------------------------
//   Invoke a closure loading the function pointer dynamically
// ----------------------------------------------------------------------------
{
    // Get function pointer and argument
    Value_p fnPtrPtr = data.StructGEP(result, 0, "closurepp");
    Value_p fnPtr = data.Load(fnPtrPtr, "closurep");

    // Call the closure callback
    result = InvokeClosure(result, fnPtr);

    // Overwrite the function pointer to its original value
    // (actually improves optimizations by showing it doesn't change)
    code.Store(fnPtr, fnPtrPtr);

    return result;
}


Value_p CompilerFunction::NeedStorage(Tree *tree)
// ----------------------------------------------------------------------------
//    Allocate storage for a given tree
// ----------------------------------------------------------------------------
{
    Types *types = unit.types;
    MachineTypes &m = mty[types];
    Value_p result = m.storage[tree];
    if (!result)
    {
        // Get the associated machine type
        Type_p mtype = ValueMachineType(tree);

        // Create alloca to store the new form
        result = data.Alloca(mtype, "loc");
        m.storage[tree] = result;

        // If this started with a value, initialize it here
        if (m.values.count(tree))
        {
            Value_p initializer = m.values[tree];
            assert(initializer && initializer->getType() == mtype);
            code.Store(initializer, result);
        }
    }

    return result;
}


Value_p CompilerFunction::NeedClosure(Tree *tree)
// ----------------------------------------------------------------------------
//   Allocate a closure variable
// ----------------------------------------------------------------------------
{
    Types *types = unit.types;
    MachineTypes &m = mty[types];
    Value_p storage = m.closures[tree];
    if (!storage)
    {
        storage = NeedStorage(tree);
        m.closures[tree] = storage;
    }
    Value_p result = code.Load(storage);
    return result;
}


bool CompilerFunction::IsKnown(Tree *tree, uint which)
// ----------------------------------------------------------------------------
//   Check if the tree has a known local or global value
// ----------------------------------------------------------------------------
{
    Types *types = unit.types;
    MachineTypes &m = mty[types];
    if ((which & knowLocals) && m.storage.count(tree) > 0)
        return true;
    else if ((which & knowValues) && m.values.count(tree) > 0)
        return true;
    else if ((which & knowGlobals) && unit.globals.count(tree) > 0)
        return true;
    return false;
}


Value_p CompilerFunction::Known(Tree *tree, uint which)
// ----------------------------------------------------------------------------
//   Return the known local or global value if any
// ----------------------------------------------------------------------------
{
    Types *types = unit.types;
    MachineTypes &m = mty[types];
    if (which & knowLocals)
    {
        auto it = m.storage.find(tree);
        if (it != m.storage.end())
            return code.Load((*it).second, "loc");
    }
    if (which & knowValues)
    {
        auto it = m.values.find(tree);
        if (it != m.values.end())
            return (*it).second;
    }
    if (which & knowGlobals)
    {
        auto it = unit.globals.find(tree);
        if (it != unit.globals.end())
            return code.Load((*it).second, "glob");
    }
    return nullptr;
}


Value_p CompilerFunction::ConstantInteger(Integer *what)
// ----------------------------------------------------------------------------
//    Generate an Integer tree
// ----------------------------------------------------------------------------
{
    Value_p result = code.PointerConstant(compiler.integerTreePtrTy, what);
    return result;
}


Value_p CompilerFunction::ConstantReal(Real *what)
// ----------------------------------------------------------------------------
//    Generate a Real tree
// ----------------------------------------------------------------------------
{
    Value_p result = code.PointerConstant(compiler.realTreePtrTy, what);
    return result;
}


Value_p CompilerFunction::ConstantText(Text *what)
// ----------------------------------------------------------------------------
//    Generate a Text tree
// ----------------------------------------------------------------------------
{
    Value_p result = code.PointerConstant(compiler.textTreePtrTy, what);
    return result;
}


Value_p CompilerFunction::ConstantTree(Tree *what)
// ----------------------------------------------------------------------------
//    Generate a constant tree
// ----------------------------------------------------------------------------
{
    Value_p result = code.PointerConstant(compiler.treePtrTy, what);
    return result;
}


Value_p CompilerFunction::CallFormError(Tree *what)
// ----------------------------------------------------------------------------
//   Report a type error trying to evaluate some argument
// ----------------------------------------------------------------------------
{
    Value_p ptr = ConstantTree(what);
    Value_p scope = ConstantTree(context->CurrentScope());
    Value_p callVal = code.Call(unit.xl_form_error, scope, ptr);
    return callVal;
}


Type_p CompilerFunction::ValueMachineType(Tree *tree)
// ----------------------------------------------------------------------------
//    Return machine type associated to a type name or expression, if any
// ----------------------------------------------------------------------------
{
    // Check if we already found it
    Types *types = unit.types;
    MachineTypes &m = mty[types];
    Type_p type = m.mtypes[tree];
    if (type)
        return type;

    // Find the base type for the expression
    Tree *base = types->ValueType(tree);
    if (!base)
    {
        Ooops("Internal: No type deduced for $1, using integer", tree);
        return compiler.integerTy;
    }

    // Find the corresponding machine type
    type = BoxedType(base);
    if (!type)
    {
        Ooops("Internal: No type associated to $1", tree);
        return compiler.integerTy;
    }

    m.mtypes[tree] = type;

    return type;
}


void CompilerFunction::ValueMachineType(Tree *tree, Type_p type)
// ----------------------------------------------------------------------------
//    Record the global value associated to a type name or expression
// ----------------------------------------------------------------------------
{
    Types *types = unit.types;
    MachineTypes &m = mty[types];
    m.mtypes[tree] = type;
}


void CompilerFunction::AddBoxedType(Tree *type, Type_p mtype)
// ----------------------------------------------------------------------------
//   Associate a tree type to a boxed machine type
// ----------------------------------------------------------------------------
///  The tree type could be a named type, e.g. [integer], or data, e.g. [X,Y]
//   The machine type could be integerTy or StructType({integerTy, realTy})
{
    Types *types = unit.types;
    MachineTypes &m = mty[types];
    Tree *base = types->BaseType(type);
    record(boxed_types, "Add %T boxing %t (%t)", mtype, type, base);
    m.boxed[base] = mtype;
}


Type_p CompilerFunction::BoxedType(Tree *type)
// ----------------------------------------------------------------------------
//   Return the machine "boxed" type for a given tree type
// ----------------------------------------------------------------------------
{
    // Check if we already had it
    Types *types = unit.types;
    MachineTypes &m = mty[types];
    Tree *base = types->BaseType(type);
    Type_p mtype = nullptr;
    auto it = m.boxed.find(base);
    if (it != m.boxed.end())
    {
        mtype = (*it).second;
        record(boxed_types, "Boxed %t (%t) is %T", type, base, mtype);
        return mtype;
    }

    // Check if we have one of the basic types
#define CTYPE(name, cty)        if (base==name##_type) mtype = compiler.cty##Ty
#define STYPE(name)             CTYPE(name, name)
#define TTYPE(name)             CTYPE(name, name##TreePtr)

    // Check types for constants
    switch(type->Kind())
    {
    case INTEGER:
        mtype = compiler.integerTy;
        base = integer_type;
        break;
    case REAL:
        mtype = compiler.realTy;
        base = real_type;
        break;
    case TEXT:
        if (((Text *)type)->IsCharacter())
        {
            mtype = compiler.characterTy;
            base = character_type;
        }
        else
        {
            mtype = compiler.charPtrTy;
            base = text_type;
        }
        break;
    case NAME:
        if (base == xl_true || base == xl_false)
        {
            mtype = compiler.booleanTy;
            base = boolean_type;
        }
        if (base == xl_nil)
            mtype = compiler.voidTy;
        if (base == xl_error)
            mtype = compiler.treePtrTy;
        STYPE(boolean);
        STYPE(integer);
        STYPE(integer8);
        STYPE(integer16);
        STYPE(integer32);
        STYPE(integer64);
        STYPE(unsigned);
        CTYPE(unsigned8,        integer8);
        CTYPE(unsigned16,       integer16);
        CTYPE(unsigned32,       integer32);
        CTYPE(unsigned64,       integer64);
        STYPE(character);
        CTYPE(text,             charPtr);
        STYPE(real);
        STYPE(real32);
        STYPE(real64);
        CTYPE(tree,             treePtr);
        CTYPE(value,            treePtr);
        CTYPE(name,             nameTreePtr);
        CTYPE(symbol,           nameTreePtr);
        CTYPE(operator,         nameTreePtr);
        TTYPE(infix);
        CTYPE(declaration,      infixTreePtr);
        TTYPE(prefix);
        TTYPE(postfix);
        TTYPE(block);
        break;

    case INFIX:
        if (Infix *range = types->IsRangeType(type))
            mtype = BoxedType(range->left);
        break;

    case PREFIX:
        break;

    case POSTFIX:
        break;

    case BLOCK:
        if (Block *block = (Block *) type)
            mtype = BoxedType(block->child);
        break;
    }

    if (mtype)
    {
        record(boxed_types, "New boxed %T for %t (%t)", mtype, type, base);
        m.boxed[base] = mtype;
    }

    return mtype;
}


CompilerFunction *CompilerFunction::RewriteFunction(RewriteCandidate *rc)
// ----------------------------------------------------------------------------
//   Create a function for a tree rewrite
// ----------------------------------------------------------------------------
{
    Rewrite *rewrite = rc->rewrite;

    Tree *rwform = RewriteDefined(rewrite->left);
    Tree *def = rewrite->right;
    record(compiler_function, "RewriteFunction %t defined as %t", rwform, def);
    if (Name *self = def->AsName())
        if (self->value == "self")
            def = nullptr;

    // Extract parameters from source form
    Save<Types_p> saveTypes(unit.types, rc->btypes);
    ParameterList plist(*this);
    if (!rwform->Do(plist))
    {
        record(compiler_function,
               "RewriteFunction could not extract parameters for %t", rwform);
        return NULL;
    }
    Parameters &parms = plist.parameters;

    // Create the function signature, one entry per parameter
    Signature signature;
    bool hasClosures = false;
    RewriteBindings &bnds = rc->bindings;
    RewriteBindings::iterator b = bnds.begin();
    for (Parameters::iterator p = parms.begin(); p != parms.end(); p++, b++)
    {
        assert (b != bnds.end());
        RewriteBinding &binding = *b;
        if (Value_p closure = binding.closure)
        {
            // Deferred evaluation: pass evaluation function pointer and arg
            Type_p argTy = closure->getType();
            signature.push_back(argTy);
            hasClosures = true;
        }
        else
        {
            // Regular evaluation: just pass argument around
            signature.push_back((*p).type);
        }
    }

    // Name for the generated function
    text label = "xl." + plist.name;

    // Compute return type:
    // - If explicitly specified, use that (already checked by TypeAnalysis)
    // - For definitions, infer from definition
    // - For data forms, this is the type of the data form
    Type_p retTy;
    if (Type_p specifiedRetTy = plist.returned)
        retTy = specifiedRetTy;
    else if (def)
        retTy = ReturnType(def);
    else
        retTy = StructureType(signature, rwform);

    // Check if we are actually declaring a C function
    bool isC = false;
    if (Tree *defined = plist.defined)
    {
        if (Name *name = def->AsName())
            if (name->value == "C")
                if (IsValidCName(defined, label))
                    isC = true;

        if (Prefix *prefix = def->AsPrefix())
            if (Name *name = prefix->left->AsName())
                if (name->value == "C")
                    if (IsValidCName(prefix->right, label))
                        isC = true;
    }

    Scope *scope = context->CurrentScope();
    CompilerFunction *f = isC
        ? new CompilerFunction(*this, scope, rwform, label, retTy, parms)
        : new CompilerFunction(*this, scope, def, rwform,
                               label, retTy, parms);
    record(compiler_unit, "Rewrite function for %t is %p %+s",
           rwform, f, isC ? "is C" : "from XL source");
    return f;
}


bool CompilerFunction::IsValidCName(Tree *tree, text &label)
// ----------------------------------------------------------------------------
//   Check if the name is valid for C
// ----------------------------------------------------------------------------
{
    uint len = 0;

    if (Name *name = tree->AsName())
    {
        label = name->value;
        len = label.length();
    }
    else if (Text *text = tree->AsText())
    {
        label = text->value;
        len = label.length();
    }

    if (len == 0)
    {
        Ooops("No valid C name in $1", tree);
        return false;
    }

    // We will NOT call functions beginning with _ (internal functions)
    for (uint i = 0; i < len; i++)
    {
        char c = label[i];
        if (!isalpha(c) && c != '_' && !(i && isdigit(c)))
        {
            Ooops("C name $1 contains invalid characters", tree);
            return false;
        }
    }
    return true;
}


Type_p CompilerFunction::ReturnType(Tree *parmForm)
// ----------------------------------------------------------------------------
//   Compute the return type associated with the given form
// ----------------------------------------------------------------------------
{
    // Type inference gives us the return type for this form
    Types *types = unit.types;
    Tree *type = types->ValueType(parmForm);
    Type_p mtype = BoxedType(type);
    if (!mtype)
        mtype = jit.VoidType();
    return mtype;
}


Type_p CompilerFunction::StructureType(const Signature &signature, Tree *rwform)
// ----------------------------------------------------------------------------
//   Compute the return type associated with a data form
// ----------------------------------------------------------------------------
{
    Types *types = unit.types;
    MachineTypes &m = mty[types];
    Tree *base = types->ValueType(rwform);

    // Check if we already had this signature
    auto it = m.mtypes.find(base);
    if (it != m.mtypes.end())
        return (*it).second;

    // Build the corresponding structure type
    StructType_p stype = jit.StructType(signature, "boxed");

    // Record boxing and unboxing for that particular tree
    AddBoxedType(base, stype);
    UnboxFunction(stype, rwform);

    return stype;
}


Value_p CompilerFunction::BoxedTree(Tree *what)
// ----------------------------------------------------------------------------
//   Compute a boxed tree value
// ----------------------------------------------------------------------------
{
    if (Name *name = what->AsName())
        what = context->Bound(name);

    // Compute the boxed type for the data
    Signature sig;
    BoxedTreeType(sig, what);
    Type_p sty = StructureType(sig, what);
    record(compiler_function, "Boxed tree %t is type %v", what, sty);

    // Generate the data
    unsigned index = 0;
    Value_p box = NeedStorage(what);
    Value_p result = Data(what, box, index);

    result = code.Load(box);
    return result;
}


void CompilerFunction::BoxedTreeType(Signature &sig, Tree *what)
// ----------------------------------------------------------------------------
//  Compute the signature for a boxed tree
// ----------------------------------------------------------------------------
{
    switch(what->Kind())
    {
    case INTEGER:
    case REAL:
    case TEXT:
        sig.push_back(ValueMachineType(what));
        break;

    case NAME:
        what = context->DeclaredForm(what);
        sig.push_back(ValueMachineType(what));
        break;

    case BLOCK:
        BoxedTreeType(sig, ((Block *) what)->child);
        break;
    case PREFIX:
        BoxedTreeType(sig, ((Prefix *) what)->left);
        BoxedTreeType(sig, ((Prefix *) what)->right);
        break;
    case POSTFIX:
        BoxedTreeType(sig, ((Postfix *) what)->left);
        BoxedTreeType(sig, ((Postfix *) what)->right);
        break;
    case INFIX:
        BoxedTreeType(sig, ((Infix *) what)->left);
        BoxedTreeType(sig, ((Infix *) what)->right);
        break;
    }
}


Value_p CompilerFunction::Primitive(Tree *what,
                                    text name,
                                    uint arity,
                                    Value_p *args)
// ----------------------------------------------------------------------------
//   Invoke an LLVM primitive, assuming it's found in the table
// ----------------------------------------------------------------------------
{
    // Find the entry in the primitives table
    auto found = primitives.find(name);
    if (found == primitives.end())
    {
        Ooops("Invalid primitive $1", what);
        return ConstantTree(what);
    }

    // If the entry doesn't have the expected arity, give up
    PrimitiveInfo &primitive = (*found).second;
    if (primitive.arity != arity)
    {
        Ooops("Primitive  arity for $1 is wrong, should be $2", what)
            .Arg(primitive.arity);
        return ConstantTree(what);
    }

    // Invoke the entry
    Value_p result = (this->*primitive.function)(what, args);
    return result;
}



// ============================================================================
//
//   Define all the LLVM wrappers
//
// ============================================================================

#define UNARY(Name)                                                     \
Value_p CompilerFunction::llvm_##Name(Tree *source, Value_p *args)      \
{                                                                       \
    return code.Name(args[0]);                                          \
}

#define BINARY(Name)                                                    \
Value_p CompilerFunction::llvm_##Name(Tree *source, Value_p *args)      \
{                                                                       \
    return code.Name(args[0], args[1]);                                 \
}

#define CAST(Name)                                                      \
Value_p CompilerFunction::llvm_##Name(Tree *source, Value_p *args)      \
{                                                                       \
    return code.Name(args[0], (Type_p) args[1]);                        \
}


#define SPECIAL(Name, Arity, Code)                                      \
Value_p CompilerFunction::llvm_##Name(Tree *source, Value_p *args)      \
{                                                                       \
    Code;                                                               \
}

#define ALIAS(from, arity, to)
#define EXTERNAL(Name, ...)

#include "compiler-primitives.tbl"

XL_END
