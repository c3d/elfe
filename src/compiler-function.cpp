// ****************************************************************************
//  compiler-function.cpp                           XL - An extensible language
// ****************************************************************************
//
//   File Description:
//
//
//
//
//
//
//
//
//
//
// ****************************************************************************
//  (C) 2018 Christophe de Dinechin <christophe@dinechin.org>
//   This software is licensed under the GNU General Public License v3
//   See LICENSE file for details.
// ****************************************************************************
// This document is released under the GNU General Public License, with the
// following clarification and exception.
//
// Linking this library statically or dynamically with other modules is making
// a combined work based on this library. Thus, the terms and conditions of the
// GNU General Public License cover the whole combination.
//
// As a special exception, the copyright holders of this library give you
// permission to link this library with independent modules to produce an
// executable, regardless of the license terms of these independent modules,
// and to copy and distribute the resulting executable under terms of your
// choice, provided that you also meet, for each linked independent module,
// the terms and conditions of the license of that module. An independent
// module is a module which is not derived from or based on this library.
// If you modify this library, you may extend this exception to your version
// of the library, but you are not obliged to do so. If you do not wish to
// do so, delete this exception statement from your version.
//
// See http://www.gnu.org/copyleft/gpl.html and Matthew 25:22 for details
//  (C) 1992-2018 Christophe de Dinechin <christophe@taodyne.com>
//  (C) 2010 Taodyne SAS
// ****************************************************************************

#include "compiler-function.h"
#include "compiler-expr.h"
#include "compiler-gc.h"
#include "basics.h"
#include <stdint.h>


RECORDER(compiler_function, 64, "Functions generated by the compiler");

XL_BEGIN

CompilerFunction::CompilerFunction(CompilerUnit &unit,
                                   Scope *scope,
                                   Tree *source,
                                   FunctionType_p type)
// ----------------------------------------------------------------------------
//   Create new compiler function for standard evaluation functions (eval_fn)
// ----------------------------------------------------------------------------
//  This is used for a top-level function, which is turned into an eval_fn
//  There is no closure since nothing can be captured from enclosing scope
    : unit(unit),
      compiler(unit.compiler),
      jit(unit.jit),
      context(new Context(scope)),
      form(nullptr),
      source(source),
      closureTy(nullptr),
      function(jit.Function(type, "xl.eval")),
      data(jit, function, "data"),
      code(jit, function, "code"),
      exit(jit, function, "exit"),
      entry(code.Block()),
      returned(data.AllocateReturnValue(function))
{
    InitializeArgs();
    record(compiler_function, "Created eval %p with scope %t type %v",
           this, scope, type);
}


CompilerFunction::CompilerFunction(CompilerFunction &caller,
                                   Scope *scope,
                                   Tree *form,
                                   Tree *body,
                                   text name,
                                   Type_p ret,
                                   const Parameters &parms)
// ----------------------------------------------------------------------------
//   Create new compiler function for optimized evaluation functions
// ----------------------------------------------------------------------------
//   This is used by rewrites like [Form is Body].
//   In that case, 'parms' have been generated to match [Form] free parms,
//   and we build a closure type if [Body] had captures from the environment
    : unit(caller.unit),
      compiler(unit.compiler),
      jit(unit.jit),
      context(new Context(scope)),
      form(form),
      source(body),
      closureTy(unit.ClosureType(form)),
      function(OptimizedFunction(name, ret, parms)),
      data(jit, function, "data"),
      code(jit, function, "code"),
      exit(jit, function, "exit"),
      entry(code.Block()),
      returned(data.AllocateReturnValue(function))
{
    InitializeArgs(parms);

    // Inherit information about machine types from the caller
    mtypes = caller.mtypes;
    boxed = caller.boxed;
    unboxed = caller.unboxed;

    record(compiler_function, "Created opt %p for %t in scope %t",
           this, source, scope);
}


CompilerFunction::CompilerFunction(CompilerFunction &caller,
                                   Scope *scope,
                                   Tree *form,
                                   text name,
                                   Type_p ret,
                                   const Parameters &parms)
// ----------------------------------------------------------------------------
//   Create new interface function for a C function
// ----------------------------------------------------------------------------
//   This is used by rewrites to interface to C code, i.e. [C strcmp]
    : unit(caller.unit),
      compiler(unit.compiler),
      jit(unit.jit),
      context(new Context(scope)),
      form(form),
      source(form),
      closureTy(nullptr),
      function(OptimizedFunction(name, ret, parms)),
      data(jit),
      code(jit),
      exit(jit),
      entry(nullptr),
      returned(nullptr)
{
    InitializeArgs(parms);

    // Inherit information about machine types from the caller
    mtypes = caller.mtypes;
    boxed = caller.boxed;
    unboxed = caller.unboxed;

    record(compiler_function, "Created external %p for %t in scope %t",
           this, source, scope);
}


CompilerFunction::CompilerFunction(CompilerFunction &caller,
                                   Scope *scope,
                                   Tree *form,
                                   text name, Type_p ret, const Signature &sig)
// ----------------------------------------------------------------------------
//   Create a new function with given signature
// ----------------------------------------------------------------------------
//   This is used for example when generating unbox functions
    : unit(caller.unit),
      compiler(unit.compiler),
      jit(unit.jit),
      context(new Context(scope)),
      form(form),
      source(form),
      closureTy(nullptr),
      function(jit.Function(jit.FunctionType(ret, sig), name)),
      data(jit, function, "data"),
      code(jit, function, "code"),
      exit(jit, function, "exit"),
      entry(code.Block()),
      returned(data.AllocateReturnValue(function))
{
    // Inherit information about machine types from the caller
    mtypes = caller.mtypes;
    boxed = caller.boxed;
    unboxed = caller.unboxed;

    record(compiler_function, "Created sys %p for %t in scope %t",
           this, source, scope);
}


CompilerFunction::~CompilerFunction()
// ----------------------------------------------------------------------------
//   Delete compiler function
// ----------------------------------------------------------------------------
{
    record(compiler_unit, "Deleted function %p for %t", this, source);
}


Function_p CompilerFunction::Function()
// ----------------------------------------------------------------------------
//   The LLVM function associated with the function
// ----------------------------------------------------------------------------
{
    return function;
}


bool CompilerFunction::IsInterfaceOnly()
// ----------------------------------------------------------------------------
//   Check if the function is an interface-only function (for C calls)
// ----------------------------------------------------------------------------
{
    return entry == nullptr;
}


Scope *CompilerFunction::FunctionScope()
// ----------------------------------------------------------------------------
//   The declaration scope associated with the function
// ----------------------------------------------------------------------------
{
    return context->CurrentScope();
}


Context *CompilerFunction::FunctionContext()
// ----------------------------------------------------------------------------
//   The declaration context for the function
// ----------------------------------------------------------------------------
{
    return context;
}


Function_p CompilerFunction::Compile(Tree *tree, bool force)
// ----------------------------------------------------------------------------
//    Compile a given tree in given function and return the associated value
// ----------------------------------------------------------------------------
{
    CompilerExpression expr(*this);
    Value_p result = expr.Evaluate(tree, force);
    if (returned)
        Return(tree, result);
    return function;
}


Value_p CompilerFunction::Return(Tree *tree, Value_p value)
// ----------------------------------------------------------------------------
//   Return the given value, after appropriate boxing
// ----------------------------------------------------------------------------
{
    Type_p retTy = jit.ReturnType(function);
    value = Autobox(tree, value, retTy);

    Type_p valTy = JIT::Type(value);
    if (valTy == retTy)
        code.Store(value, returned);
    return value;
}


eval_fn CompilerFunction::Finalize(bool createCode)
// ----------------------------------------------------------------------------
//   Finalize the build of the current function
// ----------------------------------------------------------------------------
{
    record(llvm, "Finalize function %v", function);

    // If we had closure information, finish building the closure type
    if (closureTy)
    {
        captured_set *captured = CompilerInfo::Captured(form);
        assert(captured && "There was a closure set but now it's gone");
        Signature sig;

        // First argument is always the pointer to the evaluation function
        Type_p fnTy = function->getType();
        sig.push_back(fnTy);

        // Loop over other elements that need a closure
        for (Tree *tree : *captured)
        {
            Type_p type = ValueMachineType(tree);
            sig.push_back(type);
        }

         // Build the structure type and unify it with opaque type used in decl
        closureTy = jit.StructType(closureTy, sig);

        // Load the elements from the closure during function data prologue
        Function::arg_iterator args = function->arg_begin();
        Value_p closureArg = &*args++;
        unsigned field = 1;
        for (Tree *tree : *captured)
        {
            Value_p storage = NeedStorage(tree);
            Value_p ptr = data.StructGEP(closureArg, field++, "closure_in");
            Value_p input = data.Load(ptr);
            data.Store(input, storage);
        }
    }

    // Branch to the exit block from the current main body of code
    code.Branch(exit);

    // Connect the "allocas" data prologue to the actual entry point
    data.Branch(entry);

    // Insert return in exit block
    if (returned)
    {
        Value_p retVal = exit.Load(returned, "retval");
        exit.Return(retVal);
    }
    else
    {
        exit.Return(nullptr);
    }

    // Verify the function we built
    if (RECORDER_TRACE(llvm_code) & 2)
        jit.Print("LLVM IR before verification and optimizations", function);
    if (jit.VerifyFunction(function))
    {
        Ooops("Generated code verification failed for $1 (internal)", source);
        return nullptr;
    }
    jit.Finalize(function);
    if (RECORDER_TRACE(llvm_code) & 4)
        jit.Print("LLVM IR after optimizations", function);

    void *result = NULL;
    if (createCode)
    {
        result = jit.ExecutableCode(function);
        if (RECORDER_TRACE(llvm_code) & 8)
            jit.Print("LLVM IR after machine code generation", function);
    }

    record(llvm_functions, "Function code %p for %v", result, function);
    return (eval_fn) result;
}


Function_p CompilerFunction::OptimizedFunction(text name,
                                               Type_p ret,
                                               const Parameters &parms)
// ----------------------------------------------------------------------------
//   Create an "optimized" function when we know the parameters
// ----------------------------------------------------------------------------
{
    // Create a signature that begins with closure if needed, then parms
    Signature signature;
    if (closureTy)
    {
        PointerType_p ptr = jit.PointerType(closureTy);
        signature.push_back(ptr);
    }
    for (auto &parm : parms)
    {
        signature.push_back(parm.type);
    }

    // Create the function with that signature
    FunctionType_p ft = jit.FunctionType(ret, signature);
    Function_p f = jit.Function(ft, name);
    record(compiler_function, "Function %v function %v closure %v",
           f, ft, closureTy);
    return f;
}


void CompilerFunction::InitializeArgs()
// ----------------------------------------------------------------------------
//   Initialize the arguments and return statements for eval functions
// ----------------------------------------------------------------------------
//   In that case, the arguments are (Scope *scope, Tree *self)
{
    // Associate the value for the additional arguments (read-only, no alloca)
    Function::arg_iterator args = function->arg_begin();
    Value_p scope = &*args++;
    Value_p self = &*args++;

    // Insert 'self', mapping to form, and 'scope' for the evaluation scope
    values[xl_scope] = scope;
    values[xl_self] = self;
}


void CompilerFunction::InitializeArgs(const Parameters &parms)
// ----------------------------------------------------------------------------
//   Initialize the arguments and return statements for optimized functions
// ----------------------------------------------------------------------------
//   In that case, the arguments are from the function itself
//   They may start with a closure pointer, which  we skip if it's there,
//   because Finalize() will add code to read it (and its contents)
{
    // Associate the value for the additional arguments (read-only, no alloca)
    Function::arg_iterator args = function->arg_begin();
    if (closureTy)
        args++;

    for (auto &parm : parms)
    {
        Value_p inputArg = &*args++;
        values[parm.name] = inputArg;
    }

    // Insert 'self', mapping to form, and 'scope' for the evaluation scope
    Scope *scope = context->CurrentScope();
    values[xl_scope] = data.PointerConstant(compiler.scopePtrTy, scope);
    values[xl_self] = data.PointerConstant(compiler.treePtrTy, form);
}


Value_p CompilerFunction::Compile(RewriteCandidate &rc, const Values &args)
// ----------------------------------------------------------------------------
//    Compile a given rewrite for a tree
// ----------------------------------------------------------------------------
{
    // Check if cache already contains a compilation for this function
    Scope *scope = context->CurrentScope();
    Function_p &function = unit.Compiled(scope, rc, args);
    if (function == NULL)
    {
        Rewrite *rewrite = rc.rewrite;
        CompilerFunction *rewriteFunction = RewriteFunction(rc);

        // Make sure we don't recompile in case of recursive evaluation
        function = rewriteFunction->Function();

        // Compile the body
        Tree *value = rewrite->right;
        bool data = false;
        if (Name *self = value->As<Name>())
        {
            if (self->value == "self")
            {
                // Constructor for a 'data' form, e.g. [X,Y is self]
                unsigned index = 0;
                Tree *form = RewriteDefined(rewrite->left);
                Value_p returned = rewriteFunction->Data(form, index);
                Return(value, returned);
                data = true;
            }
        }
        if (!rewriteFunction->IsInterfaceOnly())
        {
            if (!data)
            {
                // Regular function body: compile it
                rewriteFunction->Compile(value);
            }
            rewriteFunction->Finalize(false);
            function = rewriteFunction->Function();
        }
    }
    return function;
}


Value_p CompilerFunction::Data(Tree *form, unsigned &index)
// ----------------------------------------------------------------------------
//    Generate a constructor for a data form, e.g. [X,Y is self]
// ----------------------------------------------------------------------------
{
    Value_p left, right, child;

    switch(form->Kind())
    {
    case INTEGER:
    case REAL:
    case TEXT:
    {
        // For all these cases, simply compute the corresponding value
        CompilerExpression expr(*this);
        Value_p result = expr.Evaluate(form);
        return result;
    }

    case NAME:
    {
        Scope_p   scope;
        Rewrite_p rw;
        Tree      *existing;

        // Bound names are returned as is, parameters are evaluated
        existing = context->Bound(form, true, &rw, &scope);
        assert (existing || !"TypeAnalysis didn't realize a name was missing");

        // Arguments bound here are returned directly as a tree
        Tree *defined = RewriteDefined(rw->left);
        if (scope == context->CurrentScope())
        {
            if (Value_p result = Known(defined))
            {
                // Store that in the result tree
                Value_p ptr = code.StructGEP(returned, index++, "resultp");
                result = code.Store(result, ptr);
                return result;
            }
        }

        // Arguments not bound here are returned as a constant
        return ConstantTree(defined);
    }

    case INFIX:
    {
        Infix *infix = (Infix *) form;
        left = Data(infix->left, index);
        right = Data(infix->right, index);
        return right;
    }

    case PREFIX:
    {
        Prefix *prefix = (Prefix *) form;
        left = Data(prefix->left, index);
        right = Data(prefix->right, index);
        return right;
    }

    case POSTFIX:
    {
        Postfix *postfix = (Postfix *) form;
        left = Data(postfix->left, index);
        right = Data(postfix->right, index);
        return right;
    }

    case BLOCK:
    {
        Block *block = (Block *) form;
        child = Data(block->child, index);
        return child;
    }
    }

    assert (!"Unknown kind of tree in Data()");
    return ConstantTree(form);
}


Value_p CompilerFunction::Autobox(Tree *source, Value_p value, Type_p req)
// ----------------------------------------------------------------------------
//   Automatically box/unbox primitive types
// ----------------------------------------------------------------------------
//   Primitive values like integers can exist in two forms during execution:
//   - In boxed form, e.g. as a pointer to an instance of Integer
//   - In native form, e.g. as an integer
//   This function automatically converts from one to the other as necessary
{
    Type_p     type   = value->getType();
    Value_p    result = value;
    Function_p boxFn  = nullptr;

    // Short circuit if we are already there
    if (req == type)
        return result;

    // Unboxing cases
    if (req == compiler.booleanTy)
    {
        assert (type == compiler.treePtrTy || type == compiler.nameTreePtrTy);
        Value_p falsePtr = ConstantTree(xl_false);
        result = code.ICmpNE(value, falsePtr, "notfalse");
    }
    else if (req->isIntegerTy())
    {
        if (req == compiler.characterTy && type == compiler.textTreePtrTy)
        {
            // Convert text constant to character
            result = code.StructGEP(result, TEXT_VALUE_INDEX, "ubox_text");
            result = code.StructGEP(result, 0, "ubox_charpp");
            result = code.StructGEP(result, 0, "ubox_charp");
            result = code.Load(result, "ubox_char");
        }
        else
        {
            // Convert integer constants
            assert (type == compiler.integerTreePtrTy);
            result = code.StructGEP(value, INTEGER_VALUE_INDEX, "ubox_int");
            if (req != compiler.integerTy)
                result = code.Trunc(result, req);
        }
    }
    else if (req->isFloatingPointTy())
    {
        assert(type == compiler.realTreePtrTy);
        result = code.StructGEP(value, REAL_VALUE_INDEX, "ubox_real");
        if (req != compiler.realTy)
            result = code.FPTrunc(result, req);
    }
    else if (req == compiler.charPtrTy)
    {
        assert(type == compiler.textTreePtrTy);
        result = code.StructGEP(result, TEXT_VALUE_INDEX, "ubox_text");
        result = code.StructGEP(result, 0, "ubox_charpp");
        result = code.Load(result, "ubox_charp");
    }
    else if (req == compiler.textTy)
    {
        assert (type == compiler.textTreePtrTy);
        result = code.StructGEP(result, TEXT_VALUE_INDEX, "ubox_text");
    }

    // Boxing cases
    else if (type == compiler.booleanTy)
    {
        assert(req == compiler.nameTreePtrTy || req == compiler.treePtrTy);
        Value_p truep = code.PointerConstant(compiler.nameTreePtrTy, xl_true);
        Value_p falsep = code.PointerConstant(compiler.nameTreePtrTy, xl_false);
        result = code.Select(value, truep, falsep);
    }
    else if (type == compiler.characterTy &&
             (req == compiler.treePtrTy || req == compiler.textTreePtrTy))
    {
        boxFn = unit.xl_new_character;
    }
    else if (type->isIntegerTy())
    {
        assert(req == compiler.treePtrTy || req == compiler.integerTreePtrTy);
        boxFn = unit.xl_new_integer;
        if (type != compiler.integerTy)
            result = code.SExt(result, type); // REVISIT: Signed?
    }
    else if (type->isFloatingPointTy())
    {
        assert(req == compiler.treePtrTy || req == compiler.realTreePtrTy);
        boxFn = unit.xl_new_real;
        if (type != compiler.realTy)
            result = code.FPExt(result, type);
    }
    else if (type == compiler.textTy)
    {
        assert(req == compiler.treePtrTy || req == compiler.textTreePtrTy);
        boxFn = unit.xl_new_text;
    }
    else if (type == compiler.charPtrTy)
    {
        assert(req == compiler.treePtrTy || req == compiler.textTreePtrTy);
        boxFn = unit.xl_new_ctext;
    }
    else if (unboxed.count(type) &&
             (req == compiler.blockTreePtrTy ||
              req == compiler.infixTreePtrTy ||
              req == compiler.prefixTreePtrTy ||
              req == compiler.postfixTreePtrTy ||
              req == compiler.treePtrTy))
    {
        Tree *form = unboxed[type];
        boxFn = UnboxFunction(type, form);
    }

    // If we need to invoke a boxing function, do it now
    if (boxFn)
    {
        uint64_t pos = source->Position();
        Value_p posValue = code.IntegerConstant(compiler.ulongTy, pos);
        result = code.Call(boxFn, posValue, value);
        type = result->getType();
    }

    // Check if a tree type cast is required
    if (req == compiler.treePtrTy && type != req)
    {
        if (type == compiler.integerTreePtrTy ||
            type == compiler.realTreePtrTy    ||
            type == compiler.textTreePtrTy    ||
            type == compiler.nameTreePtrTy    ||
            type == compiler.blockTreePtrTy   ||
            type == compiler.prefixTreePtrTy  ||
            type == compiler.postfixTreePtrTy ||
            type == compiler.infixTreePtrTy)
            result = code.BitCast(result, req);
        else
            // If there was some inconsistency, return an error
            result = ConstantTree(xl_nil);
    }

    // Return what we built if anything
    return result;
}


Function_p CompilerFunction::UnboxFunction(Type_p type, Tree *form)
// ----------------------------------------------------------------------------
//    Create a function transforming a boxed (structure) value into tree form
// ----------------------------------------------------------------------------
{
    // Check if we have a matching boxing function
    Scope *scope = context->CurrentScope();
    Function_p &function = unit.CompiledUnbox(scope, type);

    if (!function)
    {
        // Get original form representing that data type
        Type_p mtype = compiler.TreeMachineType(form);

        // Create a function that looks like [Tree *unboxfn(boxtype *)]
        Signature sig { type };
        CompilerFunction unbox(*this, scope, form, "xl.unbox", mtype, sig);

        // Find the first input argument, which is the boxed value pointer
        function = unbox.Function();
        auto args = function->arg_begin();
        Value_p arg = &*args++;

        // Generate the code to create the unboxed tree
        unsigned index = 0;
        Value_p tree = unbox.Unbox(arg, form, index);
        tree = unbox.Autobox(form, tree, compiler.treePtrTy);
        unbox.Return(form, tree);

        // Finalize the unbox function
        unbox.Finalize(false);
    }

    return function;
}


Value_p CompilerFunction::Unbox(Value_p boxed, Tree *form, uint &index)
// ----------------------------------------------------------------------------
//   Recursively generate code to unbox a value within UnboxFunction
// ----------------------------------------------------------------------------
{
    Type_p ttp = compiler.treePtrTy;
    Value_p ref, left, right, child;

    switch(form->Kind())
    {
    default:
        assert(!"Invalid tree kind in CompilerFunction::Unbox");

    case INTEGER:
    case REAL:
    case TEXT:
    {
        // For all these cases, simply compute the corresponding value
        CompilerExpression expr(*this);
        Value_p result = form->Do(expr);
        return result;
    }

    case NAME:
    {
        Scope_p   scope;
        Rewrite_p rw;
        Tree      *existing;

        // Bound names are returned as is, parameters are evaluated
        existing = context->Bound(form, true, &rw, &scope);
        assert(existing || !"Type checking didn't realize a name is missing");

        // Arguments bound here are returned directly as a tree
        if (scope == context->CurrentScope())
        {
            // Get element from input argument
            Value_p ptr = code.StructGEP(boxed, index++, "inp");
            return code.Load(ptr);
        }

        // Arguments not bound here are returned as a constant
        Tree *defined = RewriteDefined(rw->left);
        return ConstantTree(defined);
    }

    case INFIX:
    {
        Infix *infix = (Infix *) form;
        ref = ConstantTree(infix);
        left = Unbox(boxed, infix->left, index);
        right = Unbox(boxed, infix->right, index);
        left = Autobox(infix->left, left, ttp);
        right = Autobox(infix->right, right, ttp);
        return code.Call(unit.xl_new_infix, ref, left, right);
    }

    case PREFIX:
    {
        Prefix *prefix = (Prefix *) form;
        ref = ConstantTree(prefix);
        if (prefix->left->Kind() == NAME)
            left = ConstantTree(prefix->left);
        else
            left = Unbox(boxed, prefix->left, index);
        right = Unbox(boxed, prefix->right, index);
        left = Autobox(prefix->left, left, ttp);
        right = Autobox(prefix->right, right, ttp);
        return code.Call(unit.xl_new_prefix, ref, left, right);
    }

    case POSTFIX:
    {
        Postfix *postfix = (Postfix *) form;
        ref = ConstantTree(postfix);
        left = Unbox(boxed, postfix->left, index);
        if (postfix->right->Kind() == NAME)
            right = ConstantTree(postfix->right);
        else
            right = Unbox(boxed, postfix->right, index);
        left = Autobox(postfix->left, left, ttp);
        right = Autobox(postfix->right, right, ttp);
        return code.Call(unit.xl_new_postfix, ref, left, right);
    }

    case BLOCK:
    {
        Block *block = (Block *) form;
        ref = ConstantTree(block);
        child = Unbox(boxed, block->child, index);
        child = Autobox(block->child, child, ttp);
        return code.Call(unit.xl_new_block, ref, child);
    }
    }
}


Value_p CompilerFunction::NamedClosure(Name *name, Tree *expr)
// ----------------------------------------------------------------------------
//    Compile code to pass a given tree as a closure
// ----------------------------------------------------------------------------
//    Closures are represented as functions taking a pointer to a structure
//    that will contain the values being used by the closure code
{
    Scope *scope = context->CurrentScope();
    Function_p &function = unit.CompiledClosure(scope, expr);
    if (!function)
    {
        // Add a single parameter to the signature
        PointerType_p closurePtrTy = jit.PointerType(closureTy);
        Signature sig { closurePtrTy };

        // Figure out the return type and function type
        Types *types = unit.types;
        Tree *rtype = types->ValueType(expr);
        Type_p retTy = BoxedType(rtype);
        CompilerFunction closure(*this, scope, expr, "xl.closure", retTy, sig);
        function = closure.Function();
        closure.Compile(expr);
        closure.Finalize(false);
    }

    Type_p closureType = jit.ReturnType(function);

    // Allocate a local structure to pass as the closure
    Value_p closureData = data.Alloca(closureType);
    ValueMachineType(name, closureType);
    unit.AddClosureType(closureType);

    // First, store the function pointer
    uint field = 0;
    Value_p fptr = code.StructGEP(closureData, field++, "closurep");
    code.Store(function, fptr);

    // Then loop over all values that were detected while evaluating expr
    captured_set *captured = CompilerInfo::Captured(expr);
    for (auto subexpr : *captured)
    {
        Value_p subval = Compile(subexpr);
        fptr = code.StructGEP(closureData, field++, "closureitem");
        code.Store(subval, fptr);
    }

    // Return the stack pointer that we'll use later to evaluate the closure
    return closureData;
}


Value_p CompilerFunction::InvokeClosure(Value_p result, Value_p fnPtr)
// ----------------------------------------------------------------------------
//   Invoke a closure with a known closure function
// ----------------------------------------------------------------------------
{
    result = code.Call(fnPtr, result);
    return result;
}


Value_p CompilerFunction::InvokeClosure(Value_p result)
// ----------------------------------------------------------------------------
//   Invoke a closure loading the function pointer dynamically
// ----------------------------------------------------------------------------
{
    // Get function pointer and argument
    Value_p fnPtrPtr = data.StructGEP(result, 0, "closurepp");
    Value_p fnPtr = data.Load(fnPtrPtr, "closurep");

    // Call the closure callback
    result = InvokeClosure(result, fnPtr);

    // Overwrite the function pointer to its original value
    // (actually improves optimizations by showing it doesn't change)
    code.Store(fnPtr, fnPtrPtr);

    return result;
}


Value_p CompilerFunction::NeedStorage(Tree *tree)
// ----------------------------------------------------------------------------
//    Allocate storage for a given tree
// ----------------------------------------------------------------------------
{
    Value_p result = storage[tree];
    if (!result)
    {
        // Get the associated machine type
        Type_p mtype = ValueMachineType(tree);

        // Create alloca to store the new form
        result = data.Alloca(mtype, "loc");
        storage[tree] = result;

        // If this started with a value or global, initialize on function entry
        Value_p initializer = Known(tree, knowGlobals | knowLocals);
        if (initializer && initializer->getType() == mtype)
            data.Store(initializer, result);
    }

    return result;
}


Value_p CompilerFunction::NeedClosure(Tree *tree)
// ----------------------------------------------------------------------------
//   Allocate a closure variable
// ----------------------------------------------------------------------------
{
    Value_p storage = closures[tree];
    if (!storage)
    {
        storage = NeedStorage(tree);
        closures[tree] = storage;
    }
    Value_p result = code.Load(storage);
    return result;
}


bool CompilerFunction::IsKnown(Tree *tree, uint which)
// ----------------------------------------------------------------------------
//   Check if the tree has a known local or global value
// ----------------------------------------------------------------------------
{
    if ((which & knowLocals) && storage.count(tree) > 0)
        return true;
    else if ((which & knowValues) && values.count(tree) > 0)
        return true;
    else if ((which & knowGlobals) && unit.globals.count(tree) > 0)
        return true;
    return false;
}


Value_p CompilerFunction::Known(Tree *tree, uint which)
// ----------------------------------------------------------------------------
//   Return the known local or global value if any
// ----------------------------------------------------------------------------
{
    if (which & knowLocals)
    {
        auto it = storage.find(tree);
        if (it != storage.end())
            return code.Load((*it).second, "loc");
    }
    if (which & knowValues)
    {
        auto it = values.find(tree);
        if (it != values.end())
            return (*it).second;
    }
    if (which & knowGlobals)
    {
        auto it = unit.globals.find(tree);
        if (it != unit.globals.end())
            return code.Load((*it).second, "glob");
    }
    return nullptr;
}


Value_p CompilerFunction::ConstantInteger(Integer *what)
// ----------------------------------------------------------------------------
//    Generate an Integer tree
// ----------------------------------------------------------------------------
{
    Value_p result = code.PointerConstant(compiler.integerTreePtrTy, what);
    return result;
}


Value_p CompilerFunction::ConstantReal(Real *what)
// ----------------------------------------------------------------------------
//    Generate a Real tree
// ----------------------------------------------------------------------------
{
    Value_p result = code.PointerConstant(compiler.realTreePtrTy, what);
    return result;
}


Value_p CompilerFunction::ConstantText(Text *what)
// ----------------------------------------------------------------------------
//    Generate a Text tree
// ----------------------------------------------------------------------------
{
    Value_p result = code.PointerConstant(compiler.textTreePtrTy, what);
    return result;
}


Value_p CompilerFunction::ConstantTree(Tree *what)
// ----------------------------------------------------------------------------
//    Generate a constant tree
// ----------------------------------------------------------------------------
{
    Value_p result = code.PointerConstant(compiler.treePtrTy, what);
    return result;
}


Value_p CompilerFunction::CallFormError(Tree *what)
// ----------------------------------------------------------------------------
//   Report a type error trying to evaluate some argument
// ----------------------------------------------------------------------------
{
    Value_p ptr = ConstantTree(what);
    Value_p scope = ConstantTree(context->CurrentScope());
    Value_p callVal = code.Call(unit.xl_form_error, scope, ptr);
    return callVal;
}


Type_p CompilerFunction::ValueMachineType(Tree *tree)
// ----------------------------------------------------------------------------
//    Return machine type associated to a type name or expression, if any
// ----------------------------------------------------------------------------
{
    // Check if we already found it
    Type_p type = mtypes[tree];
    if (type)
        return type;

    // Find the base type for the expression
    Types *types = unit.types;
    Tree *base = types->ValueType(tree);
    if (!base)
    {
        Ooops("Internal: No type deduced for $1, using integer", tree);
        return compiler.integerTy;
    }

    // Find the corresponding machine type
    type = BoxedType(base);
    if (!type)
    {
        Ooops("Internal: No type associated to $1", tree);
        return compiler.integerTy;
    }

    mtypes[tree] = type;

    return type;
}


void CompilerFunction::ValueMachineType(Tree *tree, Type_p type)
// ----------------------------------------------------------------------------
//    Record the global value associated to a type name or expression
// ----------------------------------------------------------------------------
{
    mtypes[tree] = type;
}


void CompilerFunction::AddBoxedType(Tree *treeType, Type_p machineType)
// ----------------------------------------------------------------------------
//   Associate a tree type to a boxed machine type
// ----------------------------------------------------------------------------
///  The tree type could be a named type, e.g. [integer], or data, e.g. [X,Y]
//   The machine type could be integerTy or StructType({integerTy, realTy})
{
    Types *types = unit.types;
    Tree *baseType = types->BaseType(treeType);
    boxed[baseType] = machineType;
    unboxed[machineType] = baseType;
}


Type_p CompilerFunction::BoxedType(Tree *type)
// ----------------------------------------------------------------------------
//   Return the machine "boxed" type for a given tree type
// ----------------------------------------------------------------------------
{
    // Check if we already had it
    Types *types = unit.types;
    Tree *base = types->BaseType(type);
    auto it = boxed.find(base);
    if (it != boxed.end())
        return (*it).second;

    // Check if we have one of the basic types
    Type_p mtype = nullptr;
#define CTYPE(name, cty)        if (base==name##_type) mtype = compiler.cty##Ty
#define STYPE(name)             CTYPE(name, name)
#define TTYPE(name)             CTYPE(name, name##TreePtr)

    // Check types for constants
    switch(type->Kind())
    {
    case INTEGER:
        mtype = compiler.integerTy;
        break;
    case REAL:
        mtype = compiler.realTy;
        break;
    case TEXT:
        mtype = compiler.charPtrTy;
        break;
    case INFIX:
        if (Infix *range = types->IsRangeType(type))
            mtype = BoxedType(range->left);
        else if (Infix *utype = types->IsUnionType(type))
            mtype = compiler.treePtrTy;
        break;

    case NAME:
        if (base == xl_true || base == xl_false)
            mtype = compiler.booleanTy;
        if (base == xl_nil)
            mtype = compiler.voidTy;
        if (base == xl_error)
            mtype = compiler.treePtrTy;
        STYPE(boolean);
        STYPE(integer);
        STYPE(integer8);
        STYPE(integer16);
        STYPE(integer32);
        STYPE(integer64);
        STYPE(unsigned);
        CTYPE(unsigned8,        integer8);
        CTYPE(unsigned16,       integer16);
        CTYPE(unsigned32,       integer32);
        CTYPE(unsigned64,       integer64);
        STYPE(character);
        CTYPE(text,             charPtr);
        STYPE(real);
        STYPE(real32);
        STYPE(real64);
        CTYPE(tree,             treePtr);
        CTYPE(value,            treePtr);
        CTYPE(name,             nameTreePtr);
        CTYPE(symbol,           nameTreePtr);
        CTYPE(operator,         nameTreePtr);
        TTYPE(infix);
        CTYPE(declaration,      infixTreePtr);
        TTYPE(prefix);
        TTYPE(postfix);
        TTYPE(block);
        break;
    }

    if (mtype)
    {
        boxed[base] = mtype;
        unboxed[mtype] = base;
    }

    return mtype;
}


Tree *CompilerFunction::TreeType(Type_p mtype)
// ----------------------------------------------------------------------------
//   Return the base tree type associated the machine type
// ----------------------------------------------------------------------------
{
    return unboxed[mtype];
}


CompilerFunction *CompilerFunction::RewriteFunction(RewriteCandidate &rc)
// ----------------------------------------------------------------------------
//   Create a function for a tree rewrite
// ----------------------------------------------------------------------------
{
    Rewrite *rewrite = rc.rewrite;

    Tree *source = RewriteDefined(rewrite->left);
    Tree *def = rewrite->right;
    record(compiler_function, "RewriteFunction %t defined as %t", source, def);

    // Extract parameters from source form
    ParameterList plist(*this);
    if (!source->Do(plist))
    {
        record(compiler_function,
               "RewriteFunction could not extract parameters for %t", source);
        return NULL;
    }
    Parameters &parms = plist.parameters;

    // Create the function signature, one entry per parameter
    Signature signature;
    bool hasClosures = false;
    RewriteBindings &bnds = rc.bindings;
    RewriteBindings::iterator b = bnds.begin();
    for (Parameters::iterator p = parms.begin(); p != parms.end(); p++, b++)
    {
        assert (b != bnds.end());
        RewriteBinding &binding = *b;
        if (Value_p closure = binding.closure)
        {
            // Deferred evaluation: pass evaluation function pointer and arg
            Type_p argTy = closure->getType();
            signature.push_back(argTy);
            hasClosures = true;
        }
        else
        {
            // Regular evaluation: just pass argument around
            signature.push_back((*p).type);
        }
    }

    // Compute return type:
    // - If explicitly specified, use that (already checked by TypeAnalysis)
    // - For definitions, infer from definition
    // - For data forms, this is the type of the data form
    Type_p retTy;
    if (Type_p specifiedRetTy = plist.returned)
        retTy = specifiedRetTy;
    else if (def)
        retTy = ReturnType(def);
    else
        retTy = StructureType(signature, source);

    text label = "xl." + plist.name;

    // Check if we are actually declaring a C function
    bool isC = false;
    if (Tree *defined = plist.defined)
    {
        if (Name *name = def->AsName())
            if (name->value == "C")
                if (IsValidCName(defined, label))
                    isC = true;

        if (Prefix *prefix = def->AsPrefix())
            if (Name *name = prefix->left->AsName())
                if (name->value == "C")
                    if (IsValidCName(prefix->right, label))
                        isC = true;
    }

    Scope *scope = context->CurrentScope();
    CompilerFunction *f = isC
        ? new CompilerFunction(*this, scope, source, label, retTy, parms)
        : new CompilerFunction(*this, scope, def, source,
                               label, retTy, parms);
    record(compiler_unit, "Rewrite function for %t is %p %+s",
           source, f, isC ? "is C" : "from XL source");
    return f;
}


bool CompilerFunction::IsValidCName(Tree *tree, text &label)
// ----------------------------------------------------------------------------
//   Check if the name is valid for C
// ----------------------------------------------------------------------------
{
    uint len = 0;

    if (Name *name = tree->AsName())
    {
        label = name->value;
        len = label.length();
    }
    else if (Text *text = tree->AsText())
    {
        label = text->value;
        len = label.length();
    }

    if (len == 0)
    {
        Ooops("No valid C name in $1", tree);
        return false;
    }

    // We will NOT call functions beginning with _ (internal functions)
    for (uint i = 0; i < len; i++)
    {
        char c = label[i];
        if (!isalpha(c) && c != '_' && !(i && isdigit(c)))
        {
            Ooops("C name $1 contains invalid characters", tree);
            return false;
        }
    }
    return true;
}


Type_p CompilerFunction::ReturnType(Tree *form)
// ----------------------------------------------------------------------------
//   Compute the return type associated with the given form
// ----------------------------------------------------------------------------
{
    // Type inference gives us the return type for this form
    Types *types = unit.types;
    Tree *type = types->ValueType(form);
    Type_p mtype = BoxedType(type);
    if (!mtype)
        mtype = jit.VoidType();
    return mtype;
}


Type_p CompilerFunction::StructureType(const Signature &signature, Tree *source)
// ----------------------------------------------------------------------------
//   Compute the return type associated with a data form
// ----------------------------------------------------------------------------
{
    // Check if we already had this signature
    if (Type_p found = ValueMachineType(source))
        return found;

    // Build the corresponding structure type
    StructType_p stype = jit.StructType(signature);
    jit.SetName(stype, "boxed");

    // Record boxing and unboxing for that particular tree
    Types *types = unit.types;
    Tree *base = types->ValueType(source);
    AddBoxedType(base, stype);

    return stype;
}


Value_p CompilerFunction::Primitive(Tree *source,
                                    text name,
                                    uint arity,
                                    Value_p *args)
// ----------------------------------------------------------------------------
//   Invoke an LLVM primitive, assuming it's found in the table
// ----------------------------------------------------------------------------
{
    // Find the entry in the primitives table
    auto found = primitives.find(name);
    if (found == primitives.end())
        return NULL;

    // If the entry doesn't have the expected arity, give up
    PrimitiveInfo &primitive = (*found).second;
    if (primitive.arity != arity)
    {
        Ooops("Primitive  arity for $1 is wrong, should be $2",
              source).Arg(primitive.arity);
        return ConstantTree(source);
    }

    // Invoke the entry
    Value_p result = (this->*primitive.function)(source, args);
    return result;
}



// ============================================================================
//
//   Define all the LLVM wrappers
//
// ============================================================================

#define UNARY(Name)                                                     \
Value_p CompilerFunction::llvm_##Name(Tree *source, Value_p *args)      \
{                                                                       \
    return code.Name(args[0]);                                          \
}

#define BINARY(Name)                                                    \
Value_p CompilerFunction::llvm_##Name(Tree *source, Value_p *args)      \
{                                                                       \
    return code.Name(args[0], args[1]);                                 \
}

#define CAST(Name)                                                      \
Value_p CompilerFunction::llvm_##Name(Tree *source, Value_p *args)      \
{                                                                       \
    return code.Name(args[0], (Type_p) args[1]);                        \
}


#define SPECIAL(Name, Arity, Code)                                      \
Value_p CompilerFunction::llvm_##Name(Tree *source, Value_p *args)      \
{                                                                       \
    Code;                                                               \
}

#define ALIAS(from, arity, to)
#define EXTERNAL(Name, ...)

#include "compiler-primitives.tbl"

XL_END
