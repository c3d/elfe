// ****************************************************************************
//  interpreter.tbl                                              XL project
// ****************************************************************************
//
//   File Description:
//
//     Opcode interpretation
//
//     Normally, opcodes defined here should match those in llvm.tbl
//     although there is strictly speaking no reason other than
//     the convenience for maintaining builtins.xl
//
//
//
//
// ****************************************************************************
//  (C) 2015 Christophe de Dinechin <christophe@taodyne.com>
//  (C) 2015 Taodyne SAS
// ****************************************************************************

BINARY_OP(Add,     Integer, Integer, Integer,      R_INT ( LEFT +  RIGHT))
BINARY_OP(FAdd,    Real,    Real,    Real,         R_REAL( LEFT +  RIGHT))
BINARY_OP(Sub,     Integer, Integer, Integer,      R_INT ( LEFT -  RIGHT))
BINARY_OP(FSub,    Real,    Real,    Real,         R_REAL( LEFT -  RIGHT))
BINARY_OP(Mul,     Integer, Integer, Integer,      R_INT ( LEFT *  RIGHT))
BINARY_OP(FMul,    Real,    Real,    Real,         R_REAL( LEFT *  RIGHT))
BINARY_OP(UDiv,    Integer, Integer, Integer,      R_INT (ULEFT / URIGHT0))
BINARY_OP(SDiv,    Integer, Integer, Integer,      R_INT ( LEFT /  RIGHT0))
BINARY_OP(FDiv,    Real,    Real,    Real,         R_REAL( LEFT /  RIGHT0))
BINARY_OP(URem,    Integer, Integer, Integer,      R_INT (ULEFT % URIGHT0))
BINARY_OP(SRem,    Integer, Integer, Integer,      R_INT ( LEFT %  RIGHT0))
BINARY_OP(FRem,    Real,    Real,    Real,         R_INT (fmod(LEFT,RIGHT0)))
BINARY_OP(Shl,     Integer, Integer, Integer,      R_INT ( LEFT << RIGHT))
BINARY_OP(LShr,    Integer, Integer, Integer,      R_INT (ULEFT >> RIGHT))
BINARY_OP(AShr,    Integer, Integer, Integer,      R_INT ( LEFT >> RIGHT))
BINARY_OP(And,     Integer, Integer, Integer,      R_INT ( LEFT &  RIGHT))
BINARY_OP(Or,      Integer, Integer, Integer,      R_INT ( LEFT |  RIGHT))
BINARY_OP(Xor,     Integer, Integer, Integer,      R_INT ( LEFT ^  RIGHT))

UNARY_OP(Neg,      Integer, Integer,               R_INT (-LEFT))
UNARY_OP(FNeg,     Real,    Real,                  R_REAL(-LEFT))
UNARY_OP(Not,      Integer, Integer,               R_INT (~LEFT))

BINARY_OP(ICmpEQ,  Name,    Integer, Integer,      R_BOOL( LEFT ==  RIGHT))
BINARY_OP(ICmpNE,  Name,    Integer, Integer,      R_BOOL( LEFT !=  RIGHT))
BINARY_OP(ICmpUGT, Name,    Integer, Integer,      R_BOOL(ULEFT >  URIGHT))
BINARY_OP(ICmpUGE, Name,    Integer, Integer,      R_BOOL(ULEFT >= URIGHT))
BINARY_OP(ICmpULT, Name,    Integer, Integer,      R_BOOL(ULEFT <  URIGHT))
BINARY_OP(ICmpULE, Name,    Integer, Integer,      R_BOOL(ULEFT <= URIGHT))
BINARY_OP(ICmpSGT, Name,    Integer, Integer,      R_BOOL( LEFT >   RIGHT))
BINARY_OP(ICmpSGE, Name,    Integer, Integer,      R_BOOL( LEFT >=  RIGHT))
BINARY_OP(ICmpSLT, Name,    Integer, Integer,      R_BOOL( LEFT <   RIGHT))
BINARY_OP(ICmpSLE, Name,    Integer, Integer,      R_BOOL( LEFT <=  RIGHT))

// The following relies on 'true' > 'false' alphabetically!!!
BINARY_OP(BCmpEQ,  Name,    Name,    Name,         R_BOOL( LEFT ==  RIGHT))
BINARY_OP(BCmpNE,  Name,    Name,    Name,         R_BOOL( LEFT !=  RIGHT))
BINARY_OP(BCmpGT,  Name,    Name,    Name,         R_BOOL( LEFT >   RIGHT))
BINARY_OP(BCmpGE,  Name,    Name,    Name,         R_BOOL( LEFT >=  RIGHT))
BINARY_OP(BCmpLT,  Name,    Name,    Name,         R_BOOL( LEFT <   RIGHT))
BINARY_OP(BCmpLE,  Name,    Name,    Name,         R_BOOL( LEFT <=  RIGHT))

BINARY_OP(FCmpOEQ, Name,    Real,    Real,         R_BOOL(LEFT == RIGHT))
BINARY_OP(FCmpONE, Name,    Real,    Real,         R_BOOL(LEFT != RIGHT))
BINARY_OP(FCmpOGT, Name,    Real,    Real,         R_BOOL(LEFT >  RIGHT))
BINARY_OP(FCmpOGE, Name,    Real,    Real,         R_BOOL(LEFT >= RIGHT))
BINARY_OP(FCmpOLT, Name,    Real,    Real,         R_BOOL(LEFT <  RIGHT))
BINARY_OP(FCmpOLE, Name,    Real,    Real,         R_BOOL(LEFT <= RIGHT))

// BINARY_OP(FCmpORD, Name,    Real,    Real,         R_BOOL(LEFT == RIGHT))
// BINARY_OP(FCmpUNO, Name,    Real,    Real,         R_BOOL(LEFT == RIGHT))

BINARY_OP(FCmpUEQ, Name,    Real,    Real,         R_BOOL(LEFT == RIGHT))
BINARY_OP(FCmpUNE, Name,    Real,    Real,         R_BOOL(LEFT != RIGHT))
BINARY_OP(FCmpUGT, Name,    Real,    Real,         R_BOOL(LEFT >  RIGHT))
BINARY_OP(FCmpUGE, Name,    Real,    Real,         R_BOOL(LEFT >= RIGHT))
BINARY_OP(FCmpULT, Name,    Real,    Real,         R_BOOL(LEFT <  RIGHT))
BINARY_OP(FCmpULE, Name,    Real,    Real,         R_BOOL(LEFT <= RIGHT))

BINARY_OP(BCmpUEQ, Name,    Name,    Name,         R_BOOL(LEFT_B ==  RIGHT_B))
BINARY_OP(BCmpUNE, Name,    Name,    Name,         R_BOOL(LEFT_B !=  RIGHT_B))
BINARY_OP(BCmpUGT, Name,    Name,    Name,         R_BOOL(LEFT_B >   RIGHT_B))
BINARY_OP(BCmpUGE, Name,    Name,    Name,         R_BOOL(LEFT_B >=  RIGHT_B))
BINARY_OP(BCmpULT, Name,    Name,    Name,         R_BOOL(LEFT_B <   RIGHT_B))
BINARY_OP(BCmpULE, Name,    Name,    Name,         R_BOOL(LEFT_B <=  RIGHT_B))
BINARY_OP(BAnd,    Name,    Name,    Name,         R_BOOL(LEFT_B and RIGHT_B))
BINARY_OP(BOr,     Name,    Name,    Name,         R_BOOL(LEFT_B or  RIGHT_B))
BINARY_OP(BXor,    Name,    Name,    Name,         R_BOOL(LEFT_B xor RIGHT_B))
UNARY_OP(BNot,     Name,    Name,                  R_BOOL(not LEFT_B))


// ============================================================================
//
//   Special opcodes that perform XL-specific operations
//
// ============================================================================

UNARY_OP(TreeKind,         Integer, Tree,          R_INT (left.Kind()))
UNARY_OP(TreeLeft,         Tree,    Prefix,        RESULT(left.left))
UNARY_OP(TreeRight,        Tree,    Prefix,        RESULT(left.right))
UNARY_OP(InfixName,        Text,    Infix,         R_TEXT(left.name))
UNARY_OP(TextOpening,      Text,    Text,          R_TEXT(left.opening))
UNARY_OP(TextClosing,      Text,    Text,          R_TEXT(left.closing))
UNARY_OP(BlockChild,       Tree,    Block,         RESULT(left.child))
UNARY_OP(BlockOpening,     Text,    Block,         R_TEXT(left.opening))
UNARY_OP(BlockClosing,     Text,    Block,         R_TEXT(left.closing))
